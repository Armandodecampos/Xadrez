<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-2.0.0">
    <title>Jogo de Xadrez</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            /* Removido background-color do body para que a imagem de fundo seja visível */
            display: flex;
            flex-direction: column; /* Organiza os filhos verticalmente */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Garante que o corpo ocupe toda a altura da viewport */
            margin: 0;
            color: #e2e8f0; /* Texto claro */
            padding: 0;
            box-sizing: border-box;
            width: 100vw; /* Garante que o body ocupe 100% da largura da viewport */
            overflow: hidden; /* Evita barras de rolagem indesejadas */
            background-color: #1a202c; /* Fundo do contêiner do jogo */
        }

        /* Estilo para o fundo da tela inicial */
        #mainMenuBackground {
            background-color: #1a202c; /* Cor de fallback caso a imagem não carregue */
            background-size: cover; /* Cobre todo o elemento */
            background-position: center; /* Centraliza a imagem */
            background-repeat: no-repeat; /* Não repete a imagem */
            background-attachment: fixed; /* Mantém o fundo fixo ao rolar (se houver rolagem) */
            z-index: 0; /* Garante que esteja atrás do conteúdo */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5vmin; /* Preenchimento interno responsivo para o contêiner (reduzido) */
            border-radius: 15px;
            /* Usando vmin para garantir que o contêiner se ajuste à menor dimensão da viewport */
            width: 99vmin; /* Ligeiramente aumentado */
            height: 99vmin; /* Ligeiramente aumentado */
            max-width: 100vw; /* Garante que não exceda a largura da viewport */
            max-height: 100vh; /* Garante que não exceda a altura da viewport */
            position: relative; /* Necessário para posicionamento absoluto do modal de promoção */
            box-sizing: border-box; /* Inclui padding na largura/altura */
            gap: 0.5vmin; /* Espaçamento entre os itens flexíveis (status, tabuleiro e botões) (reduzido) */
            overflow: hidden; /* Importante para cortar conteúdo que exceda, evitando barras de rolagem no contêiner */
            justify-content: space-between; /* Distribui o espaço verticalmente */
            align-self: center; /* Centraliza o game-container se o body for maior */
            z-index: 1; /* Garante que esteja acima do fundo da tela inicial */
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr); /* Colunas responsivas */
            grid-template-rows: repeat(8, 1fr); /* Linhas responsivas */
            border: 4px solid #4a5568;
            border-radius: 8px;
            overflow: hidden; /* Garante que os cantos arredondados se apliquem às casas */
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
            /* Removido transition: transform, pois a animação @keyframes irá controlá-lo */
            aspect-ratio: 1 / 1; /* CRUCIAL: Garante que o tabuleiro seja um quadrado */
            flex-grow: 1; /* Permite que o tabuleiro cresça para preencher o espaço disponível */
            flex-shrink: 1; /* Permite que o tabuleiro encolha se necessário */
            flex-basis: 0; /* Permite que o item flexível defina sua base como 0 e cresça */
            min-width: 0; /* Necessário para itens flexíveis */
            min-height: 0; /* Impede que o item flexível transborde seu contêiner */
            transform-origin: center center; /* Garante que a rotação e o dimensionamento sejam do centro */
            /* A transformação inicial será definida pelo JavaScript */
        }

        /* Animação para rotação e encolhimento (0 a 180 graus) */
        @keyframes rotate-and-shrink-forward {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(90deg) scale(0.7); } /* Encolhe no meio da rotação */
            100% { transform: rotate(180deg) scale(1); } /* Volta ao tamanho normal no final da rotação */
        }

        /* Animação para rotação e encolhimento (180 a 0 graus) */
        @keyframes rotate-and-shrink-backward {
            0% { transform: rotate(180deg) scale(1); } /* Começa da posição rotacionada */
            50% { transform: rotate(270deg) scale(0.7); } /* Encolhe no meio (90 deg a mais que 180) */
            100% { transform: rotate(360deg) scale(1); } /* Volta à posição original (0 deg) */
        }

        /* Aplica a animação quando a classe animating-forward é adicionada */
        .chessboard.animating-forward {
            animation: rotate-and-shrink-forward 0.8s ease-in-out forwards; /* 'forwards' mantém o estado final da animação */
        }

        /* Aplica a animação quando a classe animating-backward é adicionada */
        .chessboard.animating-backward {
            animation: rotate-and-shrink-backward 0.8s ease-in-out forwards; /* 'forwards' mantém o estado final da animação */
        }

        .square {
            width: 100%; /* Casas preenchem suas células de grade */
            aspect-ratio: 1 / 1; /* Garante que cada casa seja quadrada */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: inherit; /* Herda o tamanho da fonte da peça */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .light {
            background-color: #f0d9b5; /* Cor da casa clara */
        }

        .dark {
            background-color: #b58863; /* Cor da casa escura */
        }

        .selected {
            background-color: #6ee7b7 !important; /* Verde-azulado para peça selecionada */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
        }

        .possible-move {
            background-color: #93c5fd !important; /* Azulado para movimentos possíveis */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
        }

        .piece {
            cursor: grab;
            /* Esta linha garante que o tamanho da peça seja responsivo */
            font-size: min(6vw, 50px); /* Tamanho responsivo da peça, ajustado para preencher melhor */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s ease-out;
        }

        /* Contra-rotaciona as peças quando o tabuleiro é rotacionado para 180deg */
        .chessboard.animating-forward .piece {
            transform: rotate(180deg);
        }

        /* Contra-rotaciona as peças quando o tabuleiro está em 180deg e volta para 0deg */
        .chessboard.animating-backward .piece {
            transform: rotate(0deg); /* Volta as peças para a orientação normal */
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .white-piece {
            color: #f7fafc; /* Cor da peça branca */
        }

        .black-piece {
            color: #2d3748; /* Cor da peça preta */
        }

        .status-message {
            font-size: min(4vmin, 1.5rem); /* Tamanho da fonte responsivo para mensagem de status */
            font-weight: bold;
            text-align: center;
            color: #a0aec0; /* Cinza mais claro para status */
            flex-shrink: 0; /* Impede que a mensagem de status encolha */
        }

        .control-buttons {
            display: flex;
            gap: 1vmin; /* Espaçamento responsivo entre os botões */
            flex-wrap: wrap; /* Permite que os botões quebrem em telas menores */
            justify-content: center;
            flex-shrink: 0; /* Impede que os botões encolham */
            margin-top: 3.5vmin; /* Margem responsiva */
        }

        .game-button {
            background-color: #4299e1; /* Botão azul */
            color: white;
            padding: min(1.5vmin, 12px) min(3vmin, 25px); /* Preenchimento responsivo */
            border-radius: 10px;
            font-size: min(2.5vmin, 1.1rem); /* Tamanho da fonte responsivo */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
        }

        .game-button:hover:not(:disabled) {
            background-color: #3182ce; /* Azul mais escuro ao passar o mouse */
            transform: translateY(-2px);
        }

        .game-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .game-button:disabled {
            background-color: #6b7280; /* Cinza para desabilitado */
            cursor: not-allowed;
            opacity: 0.7;
        }

        .main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: min(6vmin, 40px); /* Preenchimento responsivo */
            border-radius: 15px;
            max-width: 500px;
            width: 100%;
            text-align: center;
            background-color: rgba(26, 32, 44, 0.8); /* Fundo semi-transparente para o menu */
            z-index: 1; /* Garante que esteja acima do fundo */
        }

        .menu-button {
            background-color: #48bb78; /* Botão verde */
            color: white;
            padding: min(2.5vmin, 15px) min(5vmin, 30px); /* Preenchimento responsivo */
            border-radius: 10px;
            font-size: min(3.5vmin, 1.3rem); /* Tamanho da fonte responsivo */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
            width: 80%;
            margin-bottom: 1.5vmin; /* Margem responsiva */
        }

        .menu-button:hover {
            background-color: #38a169; /* Verde mais escuro ao passar o mouse */
            transform: translateY(-3px);
        }

        .menu-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px (0, 0, 0, 0.3);
        }

        /* O seletor de dificuldade agora está oculto */
        .difficulty-selector {
            display: none; /* Oculta todo o seletor de dificuldade */
        }

        /* Modal de Promoção de Peão */
        .promotion-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            padding: min(4vmin, 25px); /* Preenchimento responsivo */
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            border: 2px solid #4a5568;
        }

        .promotion-modal h3 {
            font-size: min(4vmin, 1.8rem); /* Tamanho da fonte responsivo */
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 10px;
        }

        .promotion-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap; /* Permite que as opções quebrem */
            justify-content: center;
        }

        .promotion-button {
            background-color: #48bb78; /* Botão verde */
            color: white;
            padding: min(2.5vmin, 15px); /* Preenchimento responsivo */
            border-radius: 10px;
            font-size: min(5vmin, 2.5rem); /* Tamanho da fonte responsivo */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
            width: min(10vmin, 70px); /* Largura responsiva */
            height: min(10vmin, 70px); /* Altura responsiva */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .promotion-button:hover {
            background-color: #38a169; /* Verde mais escuro ao passar o mouse */
            transform: translateY(-3px);
        }

        .promotion-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Ajustes responsivos para o modal de promoção (media query original, ainda útil) */
        @media (max-width: 600px) {
            .promotion-modal {
                padding: 15px;
                width: 90%;
            }
            .promotion-modal h3 {
                font-size: 1.4rem;
            }
            .promotion-options {
                flex-wrap: wrap;
                justify-content: center;
            }
            .promotion-button {
                width: 55px;
                height: 55px;
                font-size: 2rem;
                padding: 10px;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">
    <!-- Background para a tela inicial -->
    <div id="mainMenuBackground" class="absolute inset-0 bg-cover bg-center bg-no-repeat hidden" style="background-image: url('https://dl.dropbox.com/scl/fi/3uw0rjjq8myl63qfpifkn/Xadrez.png?rlkey=elzhai342zvi7i2dh9udvcbwi&st=5ir07uua&dl=0');"></div>

    <!-- Seção do Menu Principal -->
    <div id="mainMenu" class="main-menu z-10">
        <h1 class="text-4xl font-bold mb-8 text-white">Jogo de Xadrez</h1>
        <button id="playVsComputerBtn" class="menu-button">Um Jogador</button>
        <button id="playVsPlayerBtn" class="menu-button">Dois Jogadores</button>
    </div>

    <!-- Seção do Contêiner do Jogo (inicialmente oculta) -->
    <div id="gameContainer" class="game-container hidden z-10">
        <div id="status" class="status-message">Vez das Brancas</div>
        <div id="chessboard" class="chessboard"></div>
        <div class="control-buttons">
            <button id="undoButton" class="game-button">Voltar Jogada</button>
            <button id="redoButton" class="game-button">Prosseguir Jogada</button>
            <button id="resetButton" class="game-button">Reiniciar Jogo</button>
            <button id="backToMenuButton" class="game-button">Voltar ao Menu</button>
        </div>

        <!-- Modal de Promoção de Peão (inicialmente oculto) -->
        <div id="promotionModal" class="promotion-modal hidden">
            <h3>Escolha a peça para promoção:</h3>
            <div class="promotion-options" id="promotionOptions">
                <!-- Os botões de promoção serão inseridos aqui pelo JavaScript -->
            </div>
        </div>
    </div>

    <script type="module">
        // Caracteres Unicode das peças de xadrez
        const PIECES = {
            'K': '&#9812;', 'Q': '&#9813;', 'R': '&#9814;', 'B': '&#9815;', 'N': '&#9816;', 'P': '&#9817;', // Brancas
            'k': '&#9818;', 'q': '&#9819;', 'r': '&#9820;', 'b': '&#9821;', 'n': '&#9822;', 'p': '&#9823;'  // Pretas
        };

        // Configuração inicial do tabuleiro (representação tipo FEN string)
        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let board = []; // Estado atual do tabuleiro
        let selectedPiece = null; // Armazena a posição da peça atualmente selecionada [linha, coluna]
        let currentPlayer = 'white'; // 'white' ou 'black'
        let gameOver = false;
        let gameMode = 'player'; // 'player' ou 'computer'
        let isThinking = false; // Flag para impedir a entrada do usuário enquanto a IA está pensando
        let aiSearchDepth = 2; // Profundidade de busca da IA padrão (Normal) - agora fixa

        // Flags de roque
        let whiteKingMoved = false;
        let blackKingMoved = false;
        let whiteRookLeftMoved = false; // Torre em (7,0)
        let whiteRookRightMoved = false; // Torre em (7,7)
        let blackRookLeftMoved = false; // Torre em (0,0)
        let blackRookRightMoved = false; // Torre em (0,7)

        let gameHistory = []; // Array para armazenar estados anteriores do jogo
        let historyPointer = -1; // Índice do estado atual no gameHistory

        let promotionTarget = null; // Armazena [linha, coluna] para promoção de peão

        const mainMenuElement = document.getElementById('mainMenu');
        const gameContainerElement = document.getElementById('gameContainer');
        const chessboardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const backToMenuButton = document.getElementById('backToMenuButton');
        const playVsComputerBtn = document.getElementById('playVsComputerBtn');
        const playVsPlayerBtn = document.getElementById('playVsPlayerBtn');
        const promotionModal = document.getElementById('promotionModal');
        const promotionOptions = document.getElementById('promotionOptions');
        const mainMenuBackgroundElement = document.getElementById('mainMenuBackground');

        // Valores das peças para a função de avaliação (Sinais corrigidos para a perspectiva da IA - Preto é o jogador maximizador)
        const PIECE_VALUES = {
            'P': -20000,  // Peão Branco: -1 ponto (negativo porque é ruim para o preto)
            'N': -70000,  // Cavalo Branco: -3.5 pontos
            'B': -70000,  // Bispo Branco: -3.5 pontos
            'R': -120000, // Torre Branca: -6 pontos
            'Q': -220000, // Rainha Branca: -11 pontos
            'K': -1000000000, // Rei Branco: Inestimável (grande negativo para evitar captura do rei)

            'p': 20000,   // Peão Preto: +1 ponto (positivo porque é bom para o preto)
            'n': 70000,   // Cavalo Preto: +3.5 pontos
            'b': 70000,   // Bispo Preto: +3.5 pontos
            'r': 120000,  // Torre Preta: +6 pontos
            'q': 220000, // Rainha Preta: +11 pontos
            'k': 1000000000 // Rei Preto: Inestimável
        };

        // Tabelas de posição das peças (exemplo, podem ser refinadas)
        // Os valores são adicionados ao valor base da peça. Positivo para branco, negativo para preto.
        const PAWN_POSITION_TABLE = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [5, 5, 10, 25, 25, 10, 5, 5],
            [0, 0, 0, 20, 20, 0, 0, 0],
            [5, -5, -10, 0, 0, -10, -5, 5],
            [5, 10, 10, -20, -20, 10, 10, 5],
            [0, 0, 0, 0, 0, 0, 0, 0]
        ];

        const KNIGHT_POSITION_TABLE = [
            [-50, -40, -30, -30, -30, -30, -40, -50],
            [-40, -20, 0, 0, 0, 0, -20, -40],
            [-30, 0, 10, 15, 15, 10, 0, -30],
            [-30, 5, 15, 20, 20, 15, 5, -30],
            [-30, 0, 15, 20, 20, 15, 0, -30],
            [-30, 5, 10, 15, 15, 10, 5, -30],
            [-40, -20, 0, 5, 5, 0, -20, -40],
            [-50, -40, -30, -30, -30, -30, -30, -50]
        ];

        const BISHOP_POSITION_TABLE = [
            [-20, -10, -10, -10, -10, -10, -10, -20],
            [-10, 0, 0, 0, 0, 0, 0, -10],
            [-10, 0, 5, 10, 10, 5, 0, -10],
            [-10, 5, 5, 10, 10, 5, 5, -10],
            [-10, 0, 10, 10, 10, 10, 0, -10],
            [-10, 10, 10, 10, 10, 10, 10, -10],
            [-10, 5, 0, 0, 0, 0, 5, -10],
            [-20, -10, -10, -10, -10, -10, -10, -20]
        ];

        const ROOK_POSITION_TABLE = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [5, 10, 10, 10, 10, 10, 10, 5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [0, 0, 0, 5, 5, 0, 0, 0]
        ];

        const QUEEN_POSITION_TABLE = [
            [-20, -10, -10, -5, -5, -10, -10, -20],
            [-10, 0, 0, 0, 0, 0, 0, -10],
            [-10, 0, 5, 5, 5, 5, 0, -10],
            [-5, 0, 5, 5, 5, 5, 0, -5],
            [0, 0, 5, 5, 5, 5, 0, -5],
            [-10, 5, 5, 5, 5, 5, 0, -10],
            [-10, 0, 5, 0, 0, 0, 0, -10],
            [-20, -10, -10, -5, -5, -10, -10, -20]
        ];

        const KING_POSITION_TABLE_MIDDLE_GAME = [
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-20, -30, -30, -40, -40, -30, -30, -20],
            [-10, -20, -20, -20, -20, -20, -20, -10],
            [20, 20, 0, 0, 0, 0, 20, 20],
            [20, 30, 10, 0, 0, 10, 30, 20]
        ];

        const KING_POSITION_TABLE_END_GAME = [
            [-50, -40, -30, -20, -20, -30, -40, -50],
            [-30, -20, -10, 0, 0, -10, -20, -30],
            [-30, -10, 20, 30, 30, 20, -10, -30],
            [-30, -10, 30, 40, 40, 30, -10, -30],
            [-30, -10, 30, 40, 40, 30, -10, -30],
            [-30, -10, 20, 30, 30, 20, -10, -30],
            [-30, -20, -10, 0, 0, -10, -20, -30],
            [-50, -40, -30, -20, -20, -30, -40, -50]
        ];


        // --- Zobrist Hashing e Tabela de Transposição ---
        const ZOBRIST_TABLE = {};
        let currentZobristHash = 0;
        const transpositionTable = new Map(); // Armazena {hash: {evaluation, depth, bestMove}}

        /**
         * Gera um inteiro aleatório de 32 bits.
         * @returns {number} Um inteiro aleatório de 32 bits.
         */
        function getRandom32BitInt() {
            return (Math.random() * 0x100000000) | 0; // Gera um inteiro de 32 bits
        }

        /**
         * Inicializa a tabela Zobrist com números aleatórios para cada peça em cada casa.
         * Também inicializa números aleatórios para direitos de roque, arquivo en passant e turno.
         */
        function initializeZobristTable() {
            // Peças nas casas
            for (const pieceType in PIECES) {
                ZOBRIST_TABLE[pieceType] = [];
                for (let r = 0; r < 8; r++) {
                    ZOBRIST_TABLE[pieceType][r] = [];
                    for (let c = 0; c < 8; c++) {
                        ZOBRIST_TABLE[pieceType][r][c] = getRandom32BitInt();
                    }
                }
            }

            // Direitos de roque (Rei Branco, Rainha Branca, Rei Preto, Rainha Preta)
            ZOBRIST_TABLE.castling = {
                'WK': getRandom32BitInt(),
                'WQ': getRandom32BitInt(),
                'BK': getRandom32BitInt(),
                'BQ': getRandom32BitInt()
            };

            // Para mover (Branco ou Preto)
            ZOBRIST_TABLE.turn = {
                'white': getRandom32BitInt(),
                'black': getRandom32BitInt()
            };
            // Nota: En passant não está totalmente implementado em Zobrist para simplificação nesta versão.
        }

        /**
         * Calcula o hash Zobrist para um dado estado do tabuleiro.
         * Esta função deve ser usada no início do minimax para fazer o hash do estado atual do tabuleiro.
         * @param {Array<Array<string>>} boardState - O estado do tabuleiro para fazer o hash.
         * @param {string} playerTurn - O jogador cujo turno é ('white' ou 'black').
         * @param {object} castlingFlags - Objeto com as flags de roque atuais (whiteKingMoved, etc.).
         * @returns {number} O hash Zobrist para o estado do tabuleiro dado.
         */
        function calculateBoardHash(boardState, playerTurn, castlingFlags) {
            let hash = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c];
                    if (piece) {
                        hash ^= ZOBRIST_TABLE[piece][r][c];
                    }
                }
            }

            // Adiciona direitos de roque ao hash
            if (!castlingFlags.whiteKingMoved && !castlingFlags.whiteRookRightMoved) hash ^= ZOBRIST_TABLE.castling['WK'];
            if (!castlingFlags.whiteKingMoved && !castlingFlags.whiteRookLeftMoved) hash ^= ZOBRIST_TABLE.castling['WQ'];
            if (!castlingFlags.blackKingMoved && !castlingFlags.blackRookRightMoved) hash ^= ZOBRIST_TABLE.castling['BK'];
            if (!castlingFlags.blackKingMoved && !castlingFlags.blackRookLeftMoved) hash ^= ZOBRIST_TABLE.castling['BQ'];

            // Adiciona turno ao hash
            hash ^= ZOBRIST_TABLE.turn[playerTurn];

            return hash;
        }

        // --- Fim da Configuração de Hashing Zobrist e Tabela de Transposição ---

        /**
         * Mostra o menu principal e oculta o contêiner do jogo.
         */
        function showMainMenu() {
            mainMenuElement.classList.remove('hidden');
            gameContainerElement.classList.add('hidden');
            mainMenuBackgroundElement.classList.remove('hidden'); // Mostra o fundo da tela inicial
        }

        /**
         * Mostra o contêiner do jogo e oculta o menu principal.
         */
        function showGame() {
            mainMenuElement.classList.add('hidden');
            gameContainerElement.classList.remove('hidden');
            mainMenuBackgroundElement.classList.add('hidden'); // Oculta o fundo da tela inicial
        }

        /**
         * Salva o estado atual do jogo no localStorage.
         */
        function saveGameToLocalStorage() {
            const gameState = {
                board: board,
                currentPlayer: currentPlayer,
                gameOver: gameOver,
                whiteKingMoved: whiteKingMoved,
                blackKingMoved: blackKingMoved,
                whiteRookLeftMoved: whiteRookLeftMoved,
                whiteRookRightMoved: whiteRookRightMoved,
                blackRookLeftMoved: blackRookLeftMoved,
                blackRookRightMoved: blackRookRightMoved,
                gameHistory: gameHistory, // Salva todo o histórico para desfazer/refazer
                historyPointer: historyPointer,
                gameMode: gameMode, // Este será o modo que estava ativo quando salvo
                aiSearchDepth: aiSearchDepth
            };
            try {
                // Usa uma chave específica para o modo de jogo atual
                localStorage.setItem(`chessGame_${gameMode}`, JSON.stringify(gameState));
                console.log(`Estado do jogo para ${gameMode} salvo no localStorage.`);
            } catch (e) {
                console.error('Erro ao salvar o jogo no localStorage:', e);
            }
        }

        /**
         * Carrega o estado do jogo do localStorage para um modo específico.
         * @param {string} modeToLoad - O modo de jogo a ser carregado ('computer' ou 'player').
         * @returns {boolean} True se um jogo foi carregado com sucesso, false caso contrário.
         */
        function loadGameFromLocalStorage(modeToLoad) {
            try {
                const savedGame = localStorage.getItem(`chessGame_${modeToLoad}`);
                if (savedGame) {
                    const gameState = JSON.parse(savedGame);
                    board = gameState.board;
                    currentPlayer = gameState.currentPlayer;
                    gameOver = gameState.gameOver;
                    whiteKingMoved = gameState.whiteKingMoved;
                    blackKingMoved = gameState.blackKingMoved;
                    whiteRookLeftMoved = gameState.whiteRookLeftMoved;
                    whiteRookRightMoved = gameState.whiteRookRightMoved;
                    blackRookLeftMoved = gameState.blackRookLeftMoved;
                    blackRookRightMoved = gameState.blackRookRightMoved;
                    gameHistory = gameState.gameHistory;
                    historyPointer = gameState.historyPointer;
                    gameMode = modeToLoad; // Define o gameMode para o que foi carregado
                    aiSearchDepth = gameState.aiSearchDepth || 2; // Garante que aiSearchDepth seja definido, padrão para 2

                    // Recalcula o hash Zobrist após carregar o tabuleiro
                    currentZobristHash = calculateBoardHash(board, currentPlayer, {
                        whiteKingMoved, blackKingMoved, whiteRookLeftMoved, whiteRookRightMoved, blackRookLeftMoved, blackRookRightMoved
                    });

                    renderBoard();
                    updateStatus();
                    updateHistoryButtons();
                    console.log(`Estado do jogo para ${modeToLoad} carregado do localStorage.`);

                    // Aplica a rotação do tabuleiro com base no jogador carregado (com ou sem animação, dependendo do contexto)
                    applyBoardRotation(currentPlayer);


                    // Se for a vez da IA após o carregamento, a IA faz a jogada
                    if (!gameOver && gameMode === 'computer' && currentPlayer === 'black') {
                        isThinking = true;
                        statusElement.textContent = "Computador pensando...";
                        updateHistoryButtons();
                        setTimeout(makeComputerMove, 500);
                    }
                    return true; // Jogo carregado com sucesso
                }
            } catch (e) {
                console.error('Erro ao carregar o jogo no localStorage:', e);
                localStorage.removeItem(`chessGame_${modeToLoad}`); // Limpa dados corrompidos para aquele modo
            }
            return false; // Nenhum jogo carregado
        }

        /**
         * Inicializa um novo tabuleiro de jogo e o renderiza para um modo específico.
         * Esta função sempre inicia um novo jogo, descartando qualquer estado anterior para aquele modo.
         * @param {string} mode - 'computer' ou 'player'
         */
        function initializeNewGame(mode) {
            board = JSON.parse(JSON.stringify(initialBoard)); // Copia profundamente o tabuleiro inicial
            selectedPiece = null;
            currentPlayer = 'white';
            gameOver = false;
            gameMode = mode; // Define o modo de jogo
            isThinking = false; // Reseta a flag de pensamento
            aiSearchDepth = 2; // Profundidade de busca da IA fixada para Normal (2)

            // Reseta as flags de roque
            whiteKingMoved = false;
            blackKingMoved = false;
            whiteRookLeftMoved = false;
            whiteRookRightMoved = false;
            blackRookLeftMoved = false;
            blackRookRightMoved = false;

            gameHistory = []; // Limpa o histórico
            historyPointer = -1; // Reseta o ponteiro
            transpositionTable.clear(); // Limpa a tabela de transposição para um novo jogo

            // A tabela Zobrist é inicializada uma vez em DOMContentLoaded, não há necessidade de reinicializar aqui
            // Recalcula o hash inicial com base no estado do tabuleiro inicial e nas flags
            currentZobristHash = calculateBoardHash(board, currentPlayer, {
                whiteKingMoved, blackKingMoved, whiteRookLeftMoved, whiteRookRightMoved, blackRookLeftMoved, blackRookRightMoved
            });

            saveCurrentState(); // Salva este novo estado inicial
            renderBoard();
            updateStatus();
            updateHistoryButtons();

            // Garante que o tabuleiro não esteja rotacionado no início de um novo jogo
            chessboardElement.classList.remove('animating-forward', 'animating-backward');
            chessboardElement.style.transform = 'rotate(0deg)'; // Sempre começa em 0deg
            void chessboardElement.offsetWidth; // Força reflow para garantir que o reset da transformação seja aplicado imediatamente

            // Se iniciar contra o computador, e for a vez das pretas (vez da IA), a IA faz a jogada
            if (gameMode === 'computer' && currentPlayer === 'black') {
                setTimeout(makeComputerMove, 500); // Pequeno atraso para melhor UX
            }
        }

        /**
         * Inicia um jogo em um modo específico. Ele tenta carregar um jogo salvo para aquele modo primeiro.
         * Se nenhum jogo salvo existir, ele inicializa um novo.
         * @param {string} mode - 'computer' ou 'player'
         */
        function startGameMode(mode) {
            if (!loadGameFromLocalStorage(mode)) { // Tenta carregar
                initializeNewGame(mode); // Se nenhum jogo salvo, inicia um novo
            }
            showGame(); // Sempre mostra o tabuleiro do jogo após tentar carregar/inicializar
        }


        /**
         * Salva o estado atual do jogo no histórico.
         * Se novas jogadas forem feitas após desfazer, isso trunca o histórico "futuro".
         */
        function saveCurrentState() {
            // Se desfizermos jogadas, truncamos o histórico para o ponteiro atual
            if (historyPointer < gameHistory.length - 1) {
                gameHistory = gameHistory.slice(0, historyPointer + 1);
            }
            gameHistory.push({
                board: JSON.parse(JSON.stringify(board)), // Copia profundamente o tabuleiro
                currentPlayer: currentPlayer,
                gameOver: gameOver,
                whiteKingMoved: whiteKingMoved,
                blackKingMoved: blackKingMoved,
                whiteRookLeftMoved: whiteRookLeftMoved,
                whiteRookRightMoved: whiteRookRightMoved,
                blackRookLeftMoved: blackRookLeftMoved,
                blackRookRightMoved: blackRookRightMoved,
                zobristHash: currentZobristHash // Salva o hash Zobrist atual
            });
            historyPointer++;
            updateHistoryButtons();
            saveGameToLocalStorage(); // Salva no localStorage após cada mudança de estado
        }

        /**
         * Carrega um estado de jogo específico do histórico.
         * @param {number} index - O índice do estado a ser carregado.
         */
        function loadState(index) {
            if (index >= 0 && index < gameHistory.length) {
                const state = gameHistory[index];
                board = JSON.parse(JSON.stringify(state.board));
                currentPlayer = state.currentPlayer;
                gameOver = state.gameOver;
                whiteKingMoved = state.whiteKingMoved;
                blackKingMoved = state.blackKingMoved;
                whiteRookLeftMoved = state.whiteRookLeftMoved;
                whiteRookRightMoved = state.whiteRookRightMoved;
                blackRookLeftMoved = state.blackRookLeftMoved;
                blackRookRightMoved = state.blackRookRightMoved;
                currentZobristHash = state.zobristHash; // Carrega o hash Zobrist

                selectedPiece = null; // Desseleciona qualquer peça ao carregar o estado
                renderBoard();
                updateStatus();
                updateHistoryButtons();
                saveGameToLocalStorage(); // Salva no localStorage após carregar um estado histórico

                // Aplica a rotação do tabuleiro com base no jogador carregado (com animação)
                applyBoardRotation(currentPlayer);
            }
        }

        /**
         * Desfaz a última jogada.
         */
        function undoMove() {
            if (historyPointer > 0) {
                historyPointer--;
                loadState(historyPointer);
            }
        }

        /**
         * Refaz uma jogada previamente desfeita.
         */
        function redoMove() {
            if (historyPointer < gameHistory.length - 1) {
                historyPointer++;
                loadState(historyPointer);
            }
        }

        /**
         * Atualiza o estado habilitado/desabilitado dos botões de desfazer/refazer.
         */
        function updateHistoryButtons() {
            undoButton.disabled = historyPointer <= 0 || isThinking;
            redoButton.disabled = historyPointer >= gameHistory.length - 1 || isThinking;
            // Também desabilita toda a interação do tabuleiro se o jogo acabou ou a IA está pensando ou o modal de promoção está aberto
            if (gameOver || isThinking || !promotionModal.classList.contains('hidden')) {
                chessboardElement.style.pointerEvents = 'none';
            } else {
                chessboardElement.style.pointerEvents = 'auto';
            }
        }

        /**
         * Renderiza o tabuleiro de xadrez com base no estado 'board' atual.
         */
        function renderBoard() {
            chessboardElement.innerHTML = ''; // Limpa o tabuleiro existente
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.classList.add('square', (row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const piece = board[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.classList.add('piece', isWhitePiece(piece) ? 'white-piece' : 'black-piece');
                        pieceElement.innerHTML = PIECES[piece];
                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', handleSquareClick);
                    chessboardElement.appendChild(square);
                }
            }
        }

        /**
         * Lida com um evento de clique em uma casa do tabuleiro de xadrez.
         * @param {Event} event - O evento de clique.
         */
        function handleSquareClick(event) {
            // Impede movimentos se o jogo acabou ou a IA está pensando ou o modal de promoção está aberto
            if (gameOver || isThinking || !promotionModal.classList.contains('hidden')) return;

            const targetSquare = event.currentTarget;
            const row = parseInt(targetSquare.dataset.row);
            const col = parseInt(targetSquare.dataset.col);
            const pieceAtSquare = board[row][col];

            // Se uma peça já estiver selecionada
            if (selectedPiece) {
                const [prevRow, prevCol] = selectedPiece;
                const prevPiece = board[prevRow][prevCol];

                // Se clicar na mesma peça selecionada, desseleciona-a
                if (row === prevRow && col === prevCol) {
                    deselectPiece();
                    return;
                }

                // Verifica tentativa de roque (Rei selecionado, alvo é uma casa de destino de roque)
                if (prevPiece.toLowerCase() === 'k') {
                    let rookCol = -1; // Inicializa com uma coluna inválida

                    // Roque do lado do rei (Rei move para g1/g8)
                    if ((isWhitePiece(prevPiece) && prevRow === 7 && prevCol === 4 && row === 7 && col === 6) ||
                        (isBlackPiece(prevPiece) && prevRow === 0 && prevCol === 4 && row === 0 && col === 6)) {
                        rookCol = 7; // Coluna da torre do lado do rei
                    }
                    // Roque do lado da rainha (Rei move para c1/c8)
                    else if ((isWhitePiece(prevPiece) && prevRow === 7 && prevCol === 4 && row === 7 && col === 2) ||
                             (isBlackPiece(prevPiece) && prevRow === 0 && prevCol === 4 && row === 0 && col === 2)) {
                        rookCol = 0; // Coluna da torre do lado da rainha
                    }

                    if (rookCol !== -1) { // Se for uma casa de destino de roque
                        if (isValidCastling(prevRow, prevCol, row, rookCol)) { // Passa a linha de destino do rei e a coluna original da torre
                            makeCastlingMove(prevRow, prevCol, row, rookCol);
                            deselectPiece();
                            switchPlayer();
                            saveCurrentState();
                            return; // A jogada de roque foi feita, sai do manipulador
                        }
                    }
                }

                // Tenta mover a peça selecionada (movimento regular)
                if (isValidMove(prevPiece, prevRow, prevCol, row, col)) {
                    makeMove(prevRow, prevCol, row, col);
                    // Verifica promoção de peão após fazer a jogada
                    if (prevPiece.toLowerCase() === 'p' && ((isWhitePiece(prevPiece) && row === 0) || (isBlackPiece(prevPiece) && row === 7))) {
                        promotionTarget = [row, col]; // Armazena a casa de destino para promoção
                        showPromotionModal(isWhitePiece(prevPiece));
                    } else {
                        deselectPiece();
                        switchPlayer();
                        saveCurrentState(); // Salva o estado após um movimento válido e troca de jogador
                    }
                } else {
                    // Se clicar em uma nova peça da cor do jogador atual, seleciona-a
                    if (pieceAtSquare && isCurrentPlayerPiece(pieceAtSquare)) {
                        deselectPiece(); // Desseleciona a anterior primeiro
                        selectPiece(row, col);
                    } else {
                        // Movimento inválido ou clicando na peça do oponente sem movimento válido
                        deselectPiece();
                    }
                }
            } else {
                // Nenhuma peça selecionada ainda, tenta selecionar uma
                if (pieceAtSquare && isCurrentPlayerPiece(pieceAtSquare)) {
                    selectPiece(row, col);
                }
            }
        }

        /**
         * Exibe o modal de promoção de peão.
         * @param {boolean} isWhitePawn - True se o peão for branco, false se for preto.
         */
        function showPromotionModal(isWhitePawn) {
            promotionModal.classList.remove('hidden');
            promotionOptions.innerHTML = ''; // Limpa opções anteriores

            const piecesToPromoteTo = ['Q', 'R', 'B', 'N']; // Rainha, Torre, Bispo, Cavalo
            const pieceColors = isWhitePawn ? piecesToPromoteTo : piecesToPromoteTo.map(p => p.toLowerCase());

            pieceColors.forEach(pieceChar => {
                const button = document.createElement('button');
                button.classList.add('promotion-button');
                button.innerHTML = PIECES[pieceChar];
                button.dataset.piece = pieceChar;
                button.addEventListener('click', () => handlePawnPromotion(pieceChar));
                promotionOptions.appendChild(button);
            });

            // Desabilita a interação do tabuleiro enquanto o modal estiver aberto
            chessboardElement.style.pointerEvents = 'none';
            updateHistoryButtons(); // Atualiza o estado dos botões
        }

        /**
         * Lida com a escolha de promoção de peão.
         * @param {string} chosenPiece - O caractere da peça escolhida (ex: 'Q', 'r').
         */
        function handlePawnPromotion(chosenPiece) {
            if (!promotionTarget) return; // Não deveria acontecer

            const [row, col] = promotionTarget;
            const originalPawn = board[row][col]; // Obtém o peão antes da promoção

            // Atualiza o hash Zobrist: XOR do peão, XOR da nova peça
            currentZobristHash ^= ZOBRIST_TABLE[originalPawn][row][col];
            currentZobristHash ^= ZOBRIST_TABLE[chosenPiece][row][col];

            board[row][col] = chosenPiece; // Promove o peão

            promotionModal.classList.add('hidden'); // Oculta o modal
            chessboardElement.style.pointerEvents = 'auto'; // Reabilita a interação do tabuleiro
            promotionTarget = null; // Limpa o alvo de promoção

            renderBoard();
            deselectPiece(); // Garante que nenhuma peça esteja selecionada após a promoção
            switchPlayer(); // Troca para o próximo jogador
            saveCurrentState(); // Salva o estado após a promoção
        }


        /**
         * Seleciona uma peça na linha e coluna dadas.
         * Destaca a casa selecionada e os movimentos possíveis.
         * @param {number} row - A linha da peça.
         * @param {number} col - A coluna da peça.
         */
        function selectPiece(row, col) {
            selectedPiece = [row, col];
            const squareElement = chessboardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            squareElement.classList.add('selected');

            // Destaca movimentos possíveis (apenas movimentos legais)
            const piece = board[row][col];
            const legalMoves = getLegalMoves(piece, row, col); // Usa getLegalMoves aqui
            legalMoves.forEach(([r, c]) => {
                chessboardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`).classList.add('possible-move');
            });
        }

        /**
         * Desseleciona a peça atualmente selecionada.
         * Remove os destaques da casa selecionada e dos movimentos possíveis.
         */
        function deselectPiece() {
            if (selectedPiece) {
                const [prevRow, prevCol] = selectedPiece;
                chessboardElement.querySelector(`[data-row="${prevRow}"][data-col="${prevCol}"]`).classList.remove('selected');
                selectedPiece = null;
            }
            // Remove todos os destaques de movimentos possíveis
            document.querySelectorAll('.possible-move').forEach(sq => sq.classList.remove('possible-move'));
        }

        /**
         * Verifica se uma peça pertence ao jogador atual.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça pertence ao jogador atual.
         */
        function isCurrentPlayerPiece(piece) {
            return (currentPlayer === 'white' && isWhitePiece(piece)) ||
                   (currentPlayer === 'black' && isBlackPiece(piece));
        }

        /**
         * Verifica se uma peça é branca.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça é branca.
         */
        function isWhitePiece(piece) {
            return piece === piece.toUpperCase();
        }

        /**
         * Verifica se uma peça é preta.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça é preta.
         */
        function isBlackPiece(piece) {
            return piece === piece.toLowerCase();
        }

        /**
         * Faz um movimento no tabuleiro.
         * @param {number} fromRow - Linha de partida.
         * @param {number} fromCol - Coluna de partida.
         * @param {number} toRow - Linha de destino.
         * @param {number} toCol - Coluna de destino.
         * @param {string} [promotedToPiece] - Opcional: A peça para promover (ex: 'Q', 'n').
         */
        function makeMove(fromRow, fromCol, toRow, toCol, promotedToPiece = null) {
            const movedPiece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol]; // Obtém a peça capturada antes de mover

            // Atualiza as flags de roque
            if (movedPiece === 'K') whiteKingMoved = true;
            if (movedPiece === 'k') blackKingMoved = true;
            if (movedPiece === 'R' && fromRow === 7 && fromCol === 0) whiteRookLeftMoved = true;
            if (movedPiece === 'R' && fromRow === 7 && fromCol === 7) whiteRookRightMoved = true;
            if (movedPiece === 'r' && fromRow === 0 && fromCol === 0) blackRookLeftMoved = true;
            if (movedPiece === 'r' && fromRow === 0 && fromCol === 7) blackRookRightMoved = true;

            // Atualiza o hash Zobrist para o movimento
            currentZobristHash ^= ZOBRIST_TABLE[movedPiece][fromRow][fromCol];
            if (capturedPiece) {
                currentZobristHash ^= ZOBRIST_TABLE[capturedPiece][toRow][toCol]; // XOR da peça capturada
            }

            board[toRow][toCol] = movedPiece; // Move a peça
            board[fromRow][fromCol] = ''; // Limpa a posição original

            // Verifica Promoção de Peão
            if (movedPiece.toLowerCase() === 'p' && ((isWhitePiece(movedPiece) && toRow === 0) || (isBlackPiece(movedPiece) && toRow === 7))) {
                const finalPromotedPiece = promotedToPiece || (isWhitePiece(movedPiece) ? 'Q' : 'q'); // Padrão para Rainha se não especificado pela IA ou humano
                currentZobristHash ^= ZOBRIST_TABLE[movedPiece][toRow][toCol]; // XOR do peão que acabou de se mover
                currentZobristHash ^= ZOBRIST_TABLE[finalPromotedPiece][toRow][toCol]; // XOR da nova peça promovida
                board[toRow][toCol] = finalPromotedPiece;
            } else {
                currentZobristHash ^= ZOBRIST_TABLE[movedPiece][toRow][toCol]; // XOR da peça movida (se não houver promoção)
            }

            // XOR do turno antigo e XOR do novo turno (apenas se não estiver esperando promoção humana)
            if (! (movedPiece.toLowerCase() === 'p' && ((isWhitePiece(movedPiece) && toRow === 0) || (isBlackPiece(movedPiece) && toRow === 7)) && !isThinking) ) {
                currentZobristHash ^= ZOBRIST_TABLE.turn[currentPlayer];
                const newPlayer = currentPlayer === 'white' ? 'black' : 'white';
                currentZobristHash ^= ZOBRIST_TABLE.turn[newPlayer];
            }

            renderBoard(); // Renderiza novamente o tabuleiro
        }

        /**
         * Executa um movimento de roque.
         * @param {number} kingStartRow - Linha da posição inicial do Rei.
         * @param {number} kingStartCol - Coluna da posição inicial do Rei.
         * @param {number} kingEndRow - Linha da posição final do Rei (casa de roque).
         * @param {number} rookOriginalCol - Coluna original da Torre envolvida no roque.
         */
        function makeCastlingMove(kingStartRow, kingStartCol, kingEndRow, rookOriginalCol) {
            const isWhite = isWhitePiece(board[kingStartRow][kingStartCol]);
            const kingPiece = board[kingStartRow][kingStartCol];
            const rookPiece = board[kingEndRow][rookOriginalCol]; // A Torre está na mesma linha que o rei

            // Atualiza as flags de roque
            if (isWhite) {
                whiteKingMoved = true;
                if (rookOriginalCol === 0) whiteRookLeftMoved = true; // Roque do lado da rainha
                else whiteRookRightMoved = true; // Roque do lado do rei
            } else {
                blackKingMoved = true;
                if (rookOriginalCol === 0) blackRookLeftMoved = true; // Roque do lado da rainha
                else blackRookRightMoved = true; // Roque do lado do rei
            }

            // Determina a coluna final do rei e a coluna final da torre
            let kingFinalCol;
            let rookFinalCol;
            let rookStartCol = rookOriginalCol; // Esta é a coluna inicial real da torre

            if (rookOriginalCol === 7) { // Roque do lado do rei
                kingFinalCol = kingStartCol + 2;
                rookFinalCol = kingStartCol + 1;
            } else { // Roque do lado da rainha (rookOriginalCol === 0)
                kingFinalCol = kingStartCol - 2;
                rookFinalCol = kingStartCol - 1;
            }

            // Atualiza o hash Zobrist para o roque:
            // 1. XOR da posição antiga do rei, XOR da nova posição do rei
            currentZobristHash ^= ZOBRIST_TABLE[kingPiece][kingStartRow][kingStartCol];
            currentZobristHash ^= ZOBRIST_TABLE[kingPiece][kingEndRow][kingFinalCol];
            // 2. XOR da posição antiga da torre, XOR da nova posição da torre
            currentZobristHash ^= ZOBRIST_TABLE[rookPiece][kingEndRow][rookStartCol];
            currentZobristHash ^= ZOBRIST_TABLE[rookPiece][kingEndRow][rookFinalCol];
            // 3. XOR do turno antigo e XOR do novo turno
            currentZobristHash ^= ZOBRIST_TABLE.turn[currentPlayer];
            const newPlayer = currentPlayer === 'white' ? 'black' : 'white';
            currentZobristHash ^= ZOBRIST_TABLE.turn[newPlayer];
            // 4. Também XOR de/para as mudanças nos direitos de roque (simplificado por enquanto, mas um Zobrist completo faria isso)


            // Move o Rei
            board[kingEndRow][kingFinalCol] = kingPiece;
            board[kingStartRow][kingStartCol] = '';

            // Move a Torre
            board[kingEndRow][rookFinalCol] = rookPiece;
            board[kingEndRow][rookStartCol] = '';


            renderBoard();
        }

        /**
         * Aplica a rotação do tabuleiro com base no jogador atual e no modo de jogo.
         * Gerencia as classes de animação para transições suaves.
         * @param {string} playerToRotateTo - O jogador para o qual o tabuleiro deve ser orientado ('white' ou 'black').
         */
        function applyBoardRotation(playerToRotateTo) {
            // Remove ambas as classes de animação para garantir que a animação possa ser re-acionada
            chessboardElement.classList.remove('animating-forward', 'animating-backward');

            if (gameMode === 'player') {
                // Determina a rotação inicial para a próxima animação
                // Se estamos girando PARA o preto (180deg), começamos de 0deg.
                // Se estamos girando PARA o branco (0deg), começamos de 180deg.
                const startRotationForAnimation = (playerToRotateTo === 'black') ? 'rotate(0deg)' : 'rotate(180deg)';

                // Define a transformação para o ponto de partida da animação
                chessboardElement.style.transform = startRotationForAnimation;

                // Força um reflow para fazer o navegador registrar a mudança em 'transform'
                void chessboardElement.offsetWidth;

                // Aplica a classe de animação apropriada
                if (playerToRotateTo === 'black') {
                    chessboardElement.classList.add('animating-forward');
                } else {
                    chessboardElement.classList.add('animating-backward');
                }
            } else {
                // No modo computador, sempre garante rotação de 0deg sem animação
                chessboardElement.style.transform = 'rotate(0deg)';
            }
        }

        /**
         * Troca o jogador atual.
         */
        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            applyBoardRotation(currentPlayer); // Aplica a rotação do tabuleiro
            updateStatus();

            // Verifica xeque-mate/empate por afogamento aqui
            if (isCheckmate(currentPlayer)) {
                gameOver = true;
                statusElement.textContent = `Xeque-mate! ${currentPlayer === 'white' ? 'Pretas' : 'Brancas'} Venceram!`;
            } else if (isStalemate(currentPlayer)) {
                gameOver = true;
                statusElement.textContent = `Empate por Afogamento!`;
            }

            // Se o jogo não acabou e for a vez da IA, a IA faz a jogada
            if (!gameOver && gameMode === 'computer' && currentPlayer === 'black') {
                isThinking = true;
                statusElement.textContent = "Computador pensando...";
                updateHistoryButtons(); // Desabilita botões enquanto a IA pensa
                setTimeout(makeComputerMove, 500); // Pequeno atraso para melhor UX
            } else {
                isThinking = false;
                updateHistoryButtons(); // Reabilita botões
            }
        }

        /**
         * Atualiza a mensagem de status exibida ao usuário.
         */
        function updateStatus() {
            if (!gameOver) {
                statusElement.textContent = `Vez das ${currentPlayer === 'white' ? 'Brancas' : 'Pretas'}`;
            } else {
                // Se o jogo acabou, a mensagem de status já está definida por xeque-mate/empate
                // Não há necessidade de alterá-la aqui, a menos que estejamos visualizando o estado anterior.
                if (historyPointer < gameHistory.length - 1) {
                     statusElement.textContent = `Vez das ${gameHistory[historyPointer].currentPlayer === 'white' ? 'Brancas' : 'Pretas'}`;
                }
            }
        }

        /**
         * Verifica se um movimento é válido e legal para uma dada peça.
         * Esta função também verifica se o movimento coloca ou deixa o rei do jogador atual em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} fromRow - Linha de partida.
         * @param {number} fromCol - Coluna de partida.
         * @param {number} toRow - Linha de destino.
         * @param {number} toCol - Coluna de destino.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o movimento for válido e legal.
         */
        function isValidMove(piece, fromRow, fromCol, toRow, toCol, currentBoard = board) {
            // Verificações básicas de limite
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;

            const targetPiece = currentBoard[toRow][toCol];
            const isWhitePieceFn = (p) => p === p.toUpperCase();
            const isBlackPieceFn = (p) => p === p.toLowerCase();
            const isCurrentPlayerPieceFn = (p) => (currentPlayer === 'white' && isWhitePieceFn(p)) || (currentPlayer === 'black' && isBlackPieceFn(p));

            // Não pode capturar sua própria peça
            if (targetPiece && isCurrentPlayerPieceFn(targetPiece)) {
                return false;
            }

            // Obtém os movimentos pseudo-legais para a peça (movimentos baseados no padrão da peça, ignorando a segurança do rei por enquanto)
            const pseudoLegalMoves = getPossibleMoves(piece, fromRow, fromCol, currentBoard);
            const isPseudoLegal = pseudoLegalMoves.some(([r, c]) => r === toRow && c === toCol);

            if (!isPseudoLegal) {
                return false; // Não é um padrão de movimento válido para esta peça
            }

            // --- Crucial: Simula o movimento e verifica a segurança do rei ---
            const originalPiece = currentBoard[fromRow][fromCol];
            const pieceAtTarget = currentBoard[toRow][toCol]; // Armazena o que está no destino

            // Temporariamente faz o movimento no tabuleiro
            currentBoard[toRow][toCol] = originalPiece;
            currentBoard[fromRow][fromCol] = '';

            // Lida com a promoção de peão na simulação para verificação de segurança do rei
            if (originalPiece.toLowerCase() === 'p') {
                if ((isWhitePiece(originalPiece) && toRow === 0) || (isBlackPiece(originalPiece) && toRow === 7)) {
                    // Promove para Rainha para fins de verificação de segurança do rei
                    currentBoard[toRow][toCol] = isWhitePiece(originalPiece) ? 'Q' : 'q';
                }
            }


            // Verifica se o rei *do jogador atual* está em xeque após este movimento simulado
            const kingInCheckAfterMove = isKingInCheck(currentPlayer, currentBoard);

            // Reverte o movimento
            currentBoard[fromRow][fromCol] = originalPiece;
            currentBoard[toRow][toCol] = pieceAtTarget;

            if (kingInCheckAfterMove) {
                return false; // O movimento é ilegal porque deixa o rei do jogador atual em xeque
            }

            return true; // O movimento é válido e legal
        }

        /**
         * Retorna um array de movimentos pseudo-legais para uma dada peça em uma posição específica.
         * Movimentos pseudo-legais são baseados no padrão de movimento da peça e nas regras de captura,
         * mas NÃO consideram se o movimento coloca ou deixa o rei do próprio jogador em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} row - A linha atual da peça.
         * @param {number} col - A coluna atual da peça.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {Array<Array<number>>} - Um array de pares [linha, coluna] representando movimentos pseudo-legais.
         */
        function getPossibleMoves(piece, row, col, currentBoard = board) {
            const moves = [];
            const isWhite = isWhitePiece(piece);
            const pieceType = piece.toLowerCase();

            const addMove = (r, c) => {
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = currentBoard[r][c];
                    // Se a casa de destino estiver vazia ou contiver uma peça do oponente
                    if (!targetPiece || (isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece))) {
                        moves.push([r, c]);
                    }
                }
            };

            const checkPath = (dr, dc) => {
                for (let i = 1; i < 8; i++) {
                    const r = row + i * dr;
                    const c = col + i * dc;
                    if (r < 0 || r > 7 || c < 0 || c > 7) break;
                    const targetPiece = currentBoard[r][c];
                    if (targetPiece) {
                        if ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece))) {
                            addMove(r, c); // Pode capturar
                        }
                        break; // Caminho bloqueado por qualquer peça
                    }
                    addMove(r, c);
                }
            };

            switch (pieceType) {
                case 'p': // Peão
                    const direction = isWhite ? -1 : 1;
                    const startRow = isWhite ? 6 : 1;

                    // Um único movimento para frente
                    if (currentBoard[row + direction] && !currentBoard[row + direction][col]) {
                        addMove(row + direction, col);
                        // Movimento duplo inicial para frente
                        if (row === startRow && currentBoard[row + 2 * direction] && !currentBoard[row + 2 * direction][col]) {
                            addMove(row + 2 * direction, col);
                        }
                    }

                    // Capturas (movimentos diagonais apenas se capturando)
                    // Captura à esquerda
                    if (col > 0) {
                        const targetPiece = currentBoard[row + direction]?.[col - 1];
                        if (targetPiece && ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece)))) {
                            addMove(row + direction, col - 1);
                        }
                    }
                    // Captura à direita
                    if (col < 7) {
                        const targetPiece = currentBoard[row + direction]?.[col + 1];
                        if (targetPiece && ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece)))) {
                            addMove(row + direction, col + 1);
                        }
                    }
                    break;
                case 'r': // Torre
                    checkPath(1, 0); checkPath(-1, 0); // Vertical
                    checkPath(0, 1); checkPath(0, -1); // Horizontal
                    break;
                case 'n': // Cavalo
                    const knightMoves = [
                        [2, 1], [2, -1], [-2, 1], [-2, -1],
                        [1, 2], [1, -2], [-1, 2], [-1, -2]
                    ];
                    knightMoves.forEach(([dr, dc]) => addMove(row + dr, col + dc));
                    break;
                case 'b': // Bispo
                    checkPath(1, 1); checkPath(1, -1); // Diagonal
                    checkPath(-1, 1); checkPath(-1, -1);
                    break;
                case 'q': // Rainha
                    checkPath(1, 0); checkPath(-1, 0); // Vertical
                    checkPath(0, 1); checkPath(0, -1); // Horizontal
                    checkPath(1, 1); checkPath(1, -1); // Diagonal
                    checkPath(-1, 1); checkPath(-1, -1);
                    break;
                case 'k': // Rei
                    const kingMoves = [
                        [1, 0], [-1, 0], [0, 1], [0, -1],
                        [1, 1], [1, -1], [-1, 1], [-1, -1]
                    ];
                    kingMoves.forEach(([dr, dc]) => addMove(row + dr, col + dc));

                    // Adiciona o roque como movimentos pseudo-legais (casas de destino do rei)
                    // Roque do lado do rei
                    if (isWhite) {
                        if (!whiteKingMoved && !whiteRookRightMoved &&
                            currentBoard[7][5] === '' && currentBoard[7][6] === '') {
                            moves.push([7, 6]); // Casa de destino para roque do lado do rei
                        }
                        // Roque do lado da rainha
                        if (!whiteKingMoved && !whiteRookLeftMoved &&
                            currentBoard[7][1] === '' && currentBoard[7][2] === '' && currentBoard[7][3] === '') {
                            moves.push([7, 2]); // Casa de destino para roque do lado da rainha
                        }
                    } else { // Rei Preto
                        if (!blackKingMoved && !blackRookRightMoved &&
                            currentBoard[0][5] === '' && currentBoard[0][6] === '') {
                            moves.push([0, 6]); // Casa de destino para roque do lado do rei
                        }
                        if (!blackKingMoved && !blackRookLeftMoved &&
                            currentBoard[0][1] === '' && currentBoard[0][2] === '' && currentBoard[0][3] === '') {
                            moves.push([0, 2]); // Casa de destino para roque do lado da rainha
                        }
                    }
                    break;
            }
            return moves;
        }

        /**
         * Retorna um array de movimentos verdadeiramente legais para uma dada peça em uma posição específica.
         * Movimentos legais são movimentos pseudo-legais que NÃO colocam ou deixam o rei do próprio jogador em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} row - A linha atual da peça.
         * @param {number} col - A coluna atual da peça.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {Array<Array<number>>} - Um array de pares [linha, coluna] representando movimentos legais.
         */
        function getLegalMoves(piece, row, col, currentBoard = board) {
            const pseudoLegalMoves = getPossibleMoves(piece, row, col, currentBoard); // Obtém movimentos baseados no padrão da peça
            const legalMoves = [];
            const originalCurrentPlayer = currentPlayer; // Armazena o jogador original

            pseudoLegalMoves.forEach(([toR, toC]) => {
                // Para movimentos de roque, a casa de destino é onde o Rei aterrissa.
                // Precisamos verificar as condições de roque novamente aqui, especialmente as casas atacadas.
                if (piece.toLowerCase() === 'k' && (Math.abs(toC - col) === 2)) {
                    // Este é um pseudo-movimento de roque. Determina a coluna original da torre.
                    const rookOriginalCol = (toC > col) ? 7 : 0;
                    // Passa currentBoard para isValidCastling
                    if (isValidCastling(row, col, toR, rookOriginalCol, currentBoard)) {
                        legalMoves.push([toR, toC]);
                    }
                } else {
                    // Para movimentos regulares, usa isValidMove
                    // Define temporariamente o jogador atual para aquele cujos movimentos estamos testando
                    // Isso é crucial para isValidMove verificar corretamente a segurança do rei para este jogador.
                    currentPlayer = isWhitePiece(piece) ? 'white' : 'black';

                    if (isValidMove(piece, row, col, toR, toC, currentBoard)) {
                        legalMoves.push([toR, toC]);
                    }
                }
            });

            currentPlayer = originalCurrentPlayer; // Reverte para o jogador atual original
            return legalMoves;
        }

        /**
         * Verifica se um movimento de roque é válido.
         * Esta função verifica todas as condições para o roque, incluindo histórico de movimento do rei e da torre,
         * caminho livre e segurança do rei (não em xeque, não passando por casas atacadas, não aterrissando em casa atacada).
         * @param {number} kingStartRow - A linha da posição inicial do Rei.
         * @param {number} kingStartCol - A coluna da posição inicial do Rei.
         * @param {number} kingEndRow - A linha da posição final do Rei (casa de roque).
         * @param {number} rookOriginalCol - A coluna original da Torre envolvida no roque.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o movimento de roque for válido.
         */
        function isValidCastling(kingStartRow, kingStartCol, kingEndRow, rookOriginalCol, currentBoard = board) {
            const kingPiece = currentBoard[kingStartRow][kingStartCol];
            const rookPiece = currentBoard[kingEndRow][rookOriginalCol]; // A Torre está na mesma linha que o rei

            // 1. Verifica se as peças são Rei e Torre
            if (kingPiece.toLowerCase() !== 'k' || !rookPiece || rookPiece.toLowerCase() !== 'r') return false;

            // 2. Verifica se o Rei e a Torre são da mesma cor e pertencem ao jogador atual
            if (!isCurrentPlayerPiece(kingPiece) || !isCurrentPlayerPiece(rookPiece)) return false;
            if (isWhitePiece(kingPiece) !== isWhitePiece(rookPiece)) return false;

            const isWhite = isWhitePiece(kingPiece);

            // 3. Verifica se o Rei e a Torre se moveram (usa flags globais para o jogo real, não tabuleiro simulado)
            // Nota: Para simulação de minimax, essas flags não são passadas, então esta verificação dependerá do estado global.
            // Uma IA mais robusta passaria essas flags como parte do estado simulado.
            if (isWhite) {
                if (whiteKingMoved) return false;
                if (rookOriginalCol === 0 && whiteRookLeftMoved) return false;
                if (rookOriginalCol === 7 && whiteRookRightMoved) return false;
            } else {
                if (blackKingMoved) return false;
                if (rookOriginalCol === 0 && blackRookLeftMoved) return false;
                if (rookOriginalCol === 7 && blackRookRightMoved) return false;
            }

            // 4. Verifica se o caminho entre o Rei e a Torre está livre
            if (rookOriginalCol === 7) { // Roque do lado do rei
                if (currentBoard[kingStartRow][5] !== '' || currentBoard[kingStartRow][6] !== '') return false;
            } else if (rookOriginalCol === 0) { // Roque do lado da rainha
                if (currentBoard[kingStartRow][1] !== '' || currentBoard[kingStartRow][2] !== '' || currentBoard[kingStartRow][3] !== '') return false;
            } else {
                return false; // Torre não está em uma posição de roque válida
            }

            // 5. Verifica se o Rei está atualmente em xeque
            if (isKingInCheck(isWhite ? 'white' : 'black', currentBoard)) return false;

            // 6. Verifica se o Rei passa por ou aterrissa em uma casa atacada
            const opponentColor = isWhite ? 'black' : 'white';
            if (rookOriginalCol === 7) { // Roque do lado do rei
                if (isSquareAttacked(kingStartRow, kingStartCol + 1, opponentColor, currentBoard) || // Casa por onde o Rei passa
                    isSquareAttacked(kingStartRow, kingStartCol + 2, opponentColor, currentBoard)) { // Casa onde o Rei aterrissa
                    return false;
                }
            } else if (rookOriginalCol === 0) { // Roque do lado da rainha
                if (isSquareAttacked(kingStartRow, kingStartCol - 1, opponentColor, currentBoard) || // Casa por onde o Rei passa
                    isSquareAttacked(kingStartRow, kingStartCol - 2, opponentColor, currentBoard)) { // Casa onde o Rei aterrissa
                    return false;
                }
            }

            return true;
        }

        /**
         * Encontra a posição do Rei para um dado jogador.
         * @param {string} playerColor - 'white' ou 'black'.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {Array<number>|null} - [linha, coluna] do Rei, ou null se não encontrado.
         */
        function findKing(playerColor, currentBoard = board) {
            const kingPiece = playerColor === 'white' ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === kingPiece) {
                        return [r, c];
                    }
                }
            }
            return null; // Não deveria acontecer em um jogo válido
        }

        /**
         * Verifica se o rei dado está atualmente em xeque.
         * @param {string} kingColor - A cor do rei a ser verificada ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o rei estiver em xeque.
         */
        function isKingInCheck(kingColor, currentBoard = board) {
            const kingPos = findKing(kingColor, currentBoard);
            if (!kingPos) return false; // Rei não encontrado (ex: em um estado de tabuleiro simulado onde foi capturado)

            const [kingRow, kingCol] = kingPos;
            const opponentColor = kingColor === 'white' ? 'black' : 'white';

            return isSquareAttacked(kingRow, kingCol, opponentColor, currentBoard);
        }

        /**
         * Verifica se uma casa específica é atacada por uma peça de uma dada cor.
         * Esta função é crucial para a segurança do rei e validação de roque.
         * @param {number} row - A linha da casa a ser verificada.
         * @param {number} col - A coluna da casa a ser verificada.
         * @param {string} attackerColor - A cor das peças que podem estar atacando.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se a casa for atacada por um atacante da cor especificada.
         */
        function isSquareAttacked(row, col, attackerColor, currentBoard = board) {
            const originalCurrentPlayer = currentPlayer; // Armazena o jogador original
            currentPlayer = attackerColor; // Define temporariamente o jogador atual para o atacante para usar getPossibleMoves corretamente

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    // Verifica se a peça pertence ao attackerColor
                    if (piece && ((attackerColor === 'white' && isWhitePiece(piece)) || (attackerColor === 'black' && isBlackPiece(piece)))) {
                        // Obtém os movimentos pseudo-legais que esta peça atacante *poderia* fazer
                        const attackerPseudoLegalMoves = getPossibleMoves(piece, r, c, currentBoard);

                        // Verifica se algum dos movimentos pseudo-legais do atacante visa a casa especificada
                        if (attackerPseudoLegalMoves.some(([moveR, moveC]) => moveR === row && moveC === col)) {
                            currentPlayer = originalCurrentPlayer; // Reverte antes de retornar
                            return true; // A peça atacante pode atacar a casa
                        }
                    }
                }
            }
            currentPlayer = originalCurrentPlayer; // Reverte se nenhum ataque for encontrado
            return false;
        }

        /**
         * Verifica se o jogador atual está em xeque-mate.
         * Itera por todos os movimentos legais possíveis para o jogador atual.
         * @param {string} playerColor - A cor do jogador a ser verificada ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o jogador estiver em xeque-mate.
         */
        function isCheckmate(playerColor, currentBoard = board) {
            if (!isKingInCheck(playerColor, currentBoard)) {
                return false; // Não está em xeque, então não pode ser xeque-mate
            }

            // Se estiver em xeque, verifica se há algum movimento legal para sair do xeque
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        // Obtém todos os movimentos legais para esta peça (que já considera a segurança do rei)
                        const legalMoves = getLegalMoves(piece, r, c, currentBoard);
                        if (legalMoves.length > 0) {
                            return false; // Encontrou pelo menos um movimento legal, então não é xeque-mate
                        }
                    }
                }
            }
            return true; // Nenhum movimento legal encontrado para nenhuma peça, e o rei está em xeque, então é xeque-mate
        }

        /**
         * Verifica se o jogador atual está em empate por afogamento (empate por falta de movimentos legais).
         * @param {string} playerColor - A cor do jogador a ser verificada ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o jogador estiver em empate por afogamento.
         */
        function isStalemate(playerColor, currentBoard = board) {
            if (isKingInCheck(playerColor, currentBoard)) {
                return false; // Se estiver em xeque, não é empate por afogamento (é xeque-mate se não houver movimentos legais)
            }

            // Verifica se o jogador atual tem algum movimento legal
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        const legalMoves = getLegalMoves(piece, r, c, currentBoard);
                        if (legalMoves.length > 0) {
                            return false; // Encontrou pelo menos um movimento legal, então não é empate por afogamento
                        }
                    }
                }
            }
            return true; // Nenhum movimento legal encontrado para nenhuma peça, e o rei NÃO está em xeque, então é empate por afogamento
        }

        /**
         * Avalia o estado atual do tabuleiro da perspectiva do jogador maximizador (IA, que é o preto).
         * Uma pontuação positiva favorece o preto, uma pontuação negativa favorece o branco.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser avaliado.
         * @returns {number} - A pontuação do tabuleiro.
         */
        function evaluateBoard(currentBoard) {
            let score = 0;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece) {
                        // Adiciona o valor base da peça (positivo para preto, negativo para branco)
                        score += PIECE_VALUES[piece] || 0;

                        // Adiciona a pontuação posicional
                        const pieceType = piece.toLowerCase();
                        const isWhite = isWhitePiece(piece);
                        let positionalValue = 0;

                        // As tabelas de posição são da perspectiva do branco.
                        // Para peças pretas, precisamos inverter o índice da linha para obter o valor posicional correto.
                        const tableRow = isWhite ? r : 7 - r;
                        const tableCol = c;

                        switch (pieceType) {
                            case 'p':
                                positionalValue = PAWN_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'n':
                                positionalValue = KNIGHT_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'b':
                                positionalValue = BISHOP_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'r':
                                positionalValue = ROOK_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'q':
                                positionalValue = QUEEN_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'k':
                                // Determina se é o final do jogo para usar a tabela de rei apropriada
                                // Heurística simples: se o total de peças for baixo, é final do jogo
                                let totalNonKingPieces = 0;
                                for (let i = 0; i < 8; i++) {
                                    for (let j = 0; j < 8; j++) {
                                        const p = currentBoard[i][j];
                                        if (p && p.toLowerCase() !== 'k') {
                                            totalNonKingPieces++;
                                        }
                                    }
                                }
                                if (totalNonKingPieces < 8) { // Limiar arbitrário para o final do jogo
                                    positionalValue = KING_POSITION_TABLE_END_GAME[tableRow][tableCol];
                                } else {
                                    positionalValue = KING_POSITION_TABLE_MIDDLE_GAME[tableRow][tableCol];
                                }
                                break;
                        }
                        // Se for uma peça branca, seu valor posicional é subtraído da pontuação do preto.
                        // Se for uma peça preta, seu valor posicional é adicionado à pontuação do preto.
                        score += (isWhite ? -positionalValue : positionalValue);
                    }
                }
            }

            // Adiciona bônus para xeque-mate/empate por afogamento
            if (isCheckmate('white', currentBoard)) {
                score += 100000000; // Grande bônus para o preto dar xeque-mate no branco
            } else if (isCheckmate('black', currentBoard)) {
                score -= 100000000; // Grande penalidade para o preto levar xeque-mate
            } else if (isStalemate('white', currentBoard) || isStalemate('black', currentBoard)) {
                score += 0; // Empate por afogamento é um empate, sem mudança na pontuação
            }

            // Adiciona um bônus por colocar o oponente em xeque
            if (isKingInCheck('white', currentBoard)) { // Se o rei branco estiver em xeque
                score += 5000; // Bônus significativo para a IA (preto)
            }
            // Adiciona uma penalidade para o preto estar em xeque
            if (isKingInCheck('black', currentBoard)) { // Se o rei preto estiver em xeque
                score -= 5000; // Penalidade significativa para a IA (preto)
            }

            return score;
        }

        /**
         * Decide a melhor peça para promoção de peão da IA usando avaliação.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro antes da promoção.
         * @param {number} row - A linha onde o peão está promovendo.
         * @param {number} col - A coluna onde o peão está promovendo.
         * @param {boolean} isWhitePawn - True se o peão sendo promovido for branco.
         * @returns {string} O caractere da melhor peça para promover.
         */
        function decidePromotionPieceForAI(currentBoard, row, col, isWhitePawn) {
            const possiblePromotions = ['Q', 'R', 'B', 'N'];
            let bestPromotedPiece = isWhitePawn ? 'Q' : 'q'; // Padrão para Rainha
            let bestEvaluation = isWhitePawn ? Infinity : -Infinity; // Branco minimiza, Preto maximiza

            for (const pieceType of possiblePromotions) {
                const promotedPieceChar = isWhitePawn ? pieceType : pieceType.toLowerCase();
                const tempBoard = JSON.parse(JSON.stringify(currentBoard)); // Cria uma cópia

                // Promove temporariamente o peão no tabuleiro copiado
                tempBoard[row][col] = promotedPieceChar;

                const evaluation = evaluateBoard(tempBoard);

                if (isWhitePawn) { // IA Branca (jogador minimizador, mas nosso IA é preto, então este ramo não será usado)
                    if (evaluation < bestEvaluation) {
                        bestEvaluation = evaluation;
                        bestPromotedPiece = promotedPieceChar;
                    }
                } else { // IA Preta (jogador maximizador)
                    if (evaluation > bestEvaluation) {
                        bestEvaluation = evaluation;
                        bestPromotedPiece = promotedPieceChar;
                    }
                }
            }
            return bestPromotedPiece;
        }

        /**
         * Realiza uma busca de quiescência para avaliar posições ruidosas.
         * @param {Array<Array<string>>} currentBoard - O estado atual do tabuleiro.
         * @param {number} depth - A profundidade atual da busca de quiescência.
         * @param {boolean} isMaximizingPlayer - True se for o turno do jogador maximizador (IA, preto).
         * @param {number} alpha - A melhor pontuação que o jogador maximizador pode garantir até agora.
         * @param {number} beta - A melhor pontuação que o jogador minimizador pode garantir até agora.
         * @param {object} castlingFlags - Objeto com as flags de roque atuais.
         * @returns {number} - A melhor pontuação encontrada para a posição ruidosa atual.
         */
        function quiescenceSearch(currentBoard, depth, isMaximizingPlayer, alpha, beta, castlingFlags) {
            // Avalia o estado "quieto" atual (nenhum movimento tático imediato considerado ainda)
            let evaluation = evaluateBoard(currentBoard);

            if (isMaximizingPlayer) {
                alpha = Math.max(alpha, evaluation);
            } else {
                beta = Math.min(beta, evaluation);
            }

            if (alpha >= beta) {
                return evaluation; // Corte Alpha-beta
            }

            // Considera apenas movimentos de captura na busca de quiescência
            const movesToConsider = [];
            const playerColor = isMaximizingPlayer ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        const pseudoLegalMoves = getPossibleMoves(piece, r, c, currentBoard);
                        pseudoLegalMoves.forEach(([toR, toC]) => {
                            const targetPiece = currentBoard[toR][toC];
                            // Adiciona apenas se for uma captura
                            if (targetPiece && ((isWhitePiece(piece) && isBlackPiece(targetPiece)) || (isBlackPiece(piece) && isWhitePiece(targetPiece)))) {
                                // Verifica se o movimento é legal (não coloca o próprio rei em xeque)
                                const originalCurrentPlayer = currentPlayer;
                                currentPlayer = playerColor; // Define temporariamente para o jogador atual para isValidMove
                                if (isValidMove(piece, r, c, toR, toC, currentBoard)) {
                                    movesToConsider.push({
                                        from: [r, c],
                                        to: [toR, toC],
                                        piece: piece,
                                        capturedPiece: targetPiece,
                                        capturedPieceValue: Math.abs(PIECE_VALUES[targetPiece])
                                    });
                                }
                                currentPlayer = originalCurrentPlayer; // Reverte
                            }
                        });
                    }
                }
            }

            // Classifica as capturas por valor (captura mais valiosa primeiro) para melhor poda
            movesToConsider.sort((a, b) => b.capturedPieceValue - a.capturedPieceValue);

            if (isMaximizingPlayer) {
                let maxEval = evaluation; // Começa com a avaliação estática da posição atual
                for (const move of movesToConsider) {
                    const { from: [fromR, fromC], to: [toR, toC], piece } = move;

                    const newBoard = JSON.parse(JSON.stringify(currentBoard));
                    const originalPiece = newBoard[fromR][fromC];
                    const capturedPiece = newBoard[toR][toC];

                    newBoard[toR][toC] = originalPiece;
                    newBoard[fromR][fromC] = '';

                    // Promoção de Peão no tabuleiro simulado (IA sempre promove para Rainha)
                    let promotedPiece = originalPiece;
                    if (originalPiece.toLowerCase() === 'p') {
                        if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                            promotedPiece = isWhitePiece(originalPiece) ? 'Q' : 'q'; // Ainda padrão para Rainha para simplificação na busca de quiescência
                            newBoard[toR][toC] = promotedPiece; // Atualiza a peça no novo tabuleiro
                        }
                    }

                    const newCastlingFlags = { ...castlingFlags }; // Passa flags atualizadas
                    if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                    if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 0) newCastlingFlags.whiteRookLeftMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 7) newCastlingFlags.whiteRookRightMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 0) newCastlingFlags.blackRookLeftMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 7) newCastlingFlags.blackRookRightMoved = true;

                    const evalResult = quiescenceSearch(newBoard, depth - 1, false, alpha, beta, newCastlingFlags);
                    maxEval = Math.max(maxEval, evalResult);
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) {
                        break;
                    }
                }
                return maxEval;
            } else { // Jogador minimizador
                let minEval = evaluation; // Começa com a avaliação estática
                for (const move of movesToConsider) {
                    const { from: [fromR, fromC], to: [toR, toC], piece } = move;

                    const newBoard = JSON.parse(JSON.stringify(currentBoard));
                    const originalPiece = newBoard[fromR][fromC];
                    const capturedPiece = newBoard[toR][toC];

                    newBoard[toR][toC] = originalPiece;
                    newBoard[fromR][fromC] = '';

                    // Promoção de Peão no tabuleiro simulado (IA sempre promove para Rainha)
                    let promotedPiece = originalPiece;
                    if (originalPiece.toLowerCase() === 'p') {
                        if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                            promotedPiece = isWhitePiece(originalPiece) ? 'Q' : 'q'; // Ainda padrão para Rainha para simplificação na busca de quiescência
                            newBoard[toR][toC] = promotedPiece; // Atualiza a peça no novo tabuleiro
                        }
                    }

                    const newCastlingFlags = { ...castlingFlags }; // Passa flags atualizadas
                    if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                    if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 0) newCastlingFlags.whiteRookLeftMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 7) newCastlingFlags.whiteRookRightMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 0) newCastlingFlags.blackRookLeftMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 7) newCastlingFlags.blackRookRightMoved = true;

                    const evalResult = quiescenceSearch(newBoard, depth - 1, true, alpha, beta, newCastlingFlags);
                    minEval = Math.min(minEval, evalResult);
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) {
                        break;
                    }
                }
                return minEval;
            }
        }


        /**
         * Algoritmo Minimax com Poda Alpha-Beta para encontrar o melhor movimento.
         * @param {Array<Array<string>>} currentBoard - O estado atual do tabuleiro.
         * @param {number} depth - A profundidade atual da busca.
         * @param {boolean} isMaximizingPlayer - True se for o turno do jogador maximizador (IA, preto).
         * @param {number} alpha - A melhor pontuação que o jogador maximizador pode garantir até agora.
         * @param {number} beta - A melhor pontuação que o jogador minimizador pode garantir até agora.
         * @param {object} castlingFlags - Objeto com as flags de roque atuais (whiteKingMoved, etc.).
         * @returns {number} - A melhor pontuação encontrada para o estado atual do tabuleiro.
         */
        function minimax(currentBoard, depth, isMaximizingPlayer, alpha, beta, castlingFlags) {
            // Calcula o hash para o estado atual do tabuleiro
            const boardHash = calculateBoardHash(currentBoard, isMaximizingPlayer ? 'black' : 'white', castlingFlags);

            // Verifica a tabela de transposição
            if (transpositionTable.has(boardHash)) {
                const entry = transpositionTable.get(boardHash);
                if (entry.depth >= depth) { // Se a avaliação armazenada for de uma busca mais profunda ou igual
                    return entry.evaluation;
                }
            }

            // Caso base: se a profundidade for 0, chama a busca de quiescência
            if (depth === 0) {
                const evaluation = quiescenceSearch(currentBoard, 3, isMaximizingPlayer, alpha, beta, castlingFlags); // Profundidade da busca de quiescência 3
                transpositionTable.set(boardHash, { evaluation, depth });
                return evaluation;
            }

            // Verifica estados de fim de jogo
            if (isCheckmate('white', currentBoard) || isCheckmate('black', currentBoard) || isStalemate('white', currentBoard) || isStalemate('black', currentBoard)) {
                const evaluation = evaluateBoard(currentBoard); // Avalia o estado final do jogo
                transpositionTable.set(boardHash, { evaluation, depth });
                return evaluation;
            }


            if (isMaximizingPlayer) { // Turno da IA (preto) - maximiza a pontuação
                let maxEval = -Infinity;
                const playerColor = 'black';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && isBlackPiece(piece)) {
                            const moves = getLegalMoves(piece, r, c, currentBoard);
                            // Classifica os movimentos para eficiência da poda Alpha-Beta dentro do minimax
                            moves.sort((a, b) => {
                                const targetPieceA = currentBoard[a[0]][a[1]]; // Peça no destino para o movimento A
                                const targetPieceB = currentBoard[b[0]][b[1]]; // Peça no destino para o movimento B
                                const valueA = targetPieceA ? Math.abs(PIECE_VALUES[targetPieceA]) : 0;
                                const valueB = targetPieceB ? Math.abs(PIECE_VALUES[targetPieceB]) : 0;
                                return valueB - valueA; // Prioriza capturas de peças de maior valor
                            });

                            for (const [toR, toC] of moves) {
                                // Simula o movimento
                                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                                const originalPiece = newBoard[r][c];
                                const capturedPiece = newBoard[toR][toC];

                                newBoard[toR][toC] = originalPiece;
                                newBoard[r][c] = '';

                                // Promoção de Peão no tabuleiro simulado
                                let simulatedMovedPiece = originalPiece;
                                if (originalPiece.toLowerCase() === 'p') {
                                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                                    }
                                }


                                // Simula a atualização das flags de roque para a chamada recursiva
                                const newCastlingFlags = { ...castlingFlags };
                                if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                                if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 0) newCastlingFlags.whiteRookLeftMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 7) newCastlingFlags.whiteRookRightMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 0) newCastlingFlags.blackRookLeftMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 7) newCastlingFlags.blackRookRightMoved = true;

                                // Lida com o movimento simulado da torre no roque
                                if (piece.toLowerCase() === 'k' && Math.abs(toC - c) === 2) {
                                    let rookOriginalCol;
                                    let rookFinalCol;
                                    if (toC > c) { // Roque do lado do rei
                                        rookOriginalCol = 7;
                                        rookFinalCol = c + 1;
                                    } else { // Roque do lado da rainha
                                        rookOriginalCol = 0;
                                        rookFinalCol = c - 1;
                                    }
                                    const rookPiece = newBoard[r][rookOriginalCol];
                                    newBoard[r][rookFinalCol] = rookPiece;
                                    newBoard[r][rookOriginalCol] = '';
                                }

                                const evaluation = minimax(newBoard, depth - 1, false, alpha, beta, newCastlingFlags);
                                maxEval = Math.max(maxEval, evaluation);
                                alpha = Math.max(alpha, maxEval);

                                if (beta <= alpha) { // Poda Alpha-Beta
                                    break;
                                }
                            }
                        }
                    }
                }
                transpositionTable.set(boardHash, { evaluation: maxEval, depth }); // Armazena a avaliação
                return maxEval;
            } else { // Turno do oponente (branco) - minimiza a pontuação
                let minEval = Infinity;
                const playerColor = 'white';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && isWhitePiece(piece)) {
                            const moves = getLegalMoves(piece, r, c, currentBoard);
                            // Classifica os movimentos para eficiência da poda Alpha-Beta dentro do minimax
                            moves.sort((a, b) => {
                                const targetPieceA = currentBoard[a[0]][a[1]]; // Peça no destino para o movimento A
                                const targetPieceB = currentBoard[b[0]][b[1]]; // Peça no destino para o movimento B
                                const valueA = targetPieceA ? Math.abs(PIECE_VALUES[targetPieceA]) : 0;
                                const valueB = targetPieceB ? Math.abs(PIECE_VALUES[targetPieceB]) : 0;
                                return valueB - valueA; // Prioriza capturas de peças de maior valor
                            });

                            for (const [toR, toC] of moves) {
                                // Simula o movimento
                                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                                const originalPiece = newBoard[r][c];
                                const capturedPiece = newBoard[toR][toC];

                                newBoard[toR][toC] = originalPiece;
                                newBoard[r][c] = '';

                                // Promoção de Peão no tabuleiro simulado
                                let simulatedMovedPiece = originalPiece;
                                if (originalPiece.toLowerCase() === 'p') {
                                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                                    }
                                }

                                // Simula a atualização das flags de roque para a chamada recursiva
                                const newCastlingFlags = { ...castlingFlags };
                                if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                                if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 0) newCastlingFlags.whiteRookLeftMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 7) newCastlingFlags.whiteRookRightMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 0) newCastlingFlags.blackRookLeftMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 7) newCastlingFlags.blackRookRightMoved = true;

                                // Lida com o movimento simulado da torre no roque
                                if (piece.toLowerCase() === 'k' && Math.abs(toC - c) === 2) {
                                    let rookOriginalCol;
                                    let rookFinalCol;
                                    if (toC > c) { // Roque do lado do rei
                                        rookOriginalCol = 7;
                                        rookFinalCol = c + 1;
                                    } else { // Roque do lado da rainha
                                        rookOriginalCol = 0;
                                        rookFinalCol = c - 1;
                                    }
                                    const rookPiece = newBoard[r][rookOriginalCol];
                                    newBoard[r][rookFinalCol] = rookPiece;
                                    newBoard[r][rookOriginalCol] = '';
                                }

                                const evaluation = minimax(newBoard, depth - 1, true, alpha, beta, newCastlingFlags);
                                minEval = Math.min(minEval, evaluation);
                                beta = Math.min(beta, minEval);

                                if (beta <= alpha) { // Poda Alpha-Beta
                                    break;
                                }
                            }
                        }
                    }
                }
                transpositionTable.set(boardHash, { evaluation: minEval, depth }); // Armazena a avaliação
                return minEval;
            }
        }

        /**
         * Faz um movimento para o computador (IA).
         */
        function makeComputerMove() {
            if (gameOver || currentPlayer !== 'black') {
                isThinking = false;
                updateHistoryButtons();
                updateStatus(); // Garante que o status seja atualizado se a IA não deveria se mover
                return;
            }

            let bestMove = null;
            let maxEval = -Infinity;
            const searchDepth = aiSearchDepth; // Usa a profundidade de busca da IA selecionada

            // Itera por todos os movimentos possíveis para a IA (peças pretas)
            const allPossibleMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && isBlackPiece(piece)) {
                        const moves = getLegalMoves(piece, r, c, board);
                        moves.forEach(([toR, toC]) => {
                            const pieceAtTargetForMove = board[toR][toC]; // Obtém a peça do tabuleiro real antes de simular
                            allPossibleMoves.push({
                                from: [r, c],
                                to: [toR, toC],
                                piece: piece,
                                capturedPiece: pieceAtTargetForMove, // Armazena o caractere da peça capturada real
                                capturedPieceValue: pieceAtTargetForMove ? Math.abs(PIECE_VALUES[pieceAtTargetForMove]) : 0
                            });
                        });
                    }
                }
            }

            // Classifica os movimentos para eficiência da poda Alpha-Beta
            allPossibleMoves.sort((a, b) => {
                // Prioriza capturas de peças de maior valor
                if (a.capturedPieceValue !== b.capturedPieceValue) {
                    return b.capturedPieceValue - a.capturedPieceValue; // Ordem decrescente para capturas
                }

                // Se o valor capturado for o mesmo, prioriza movimentos que dão xeque
                // Simula o tabuleiro para o movimento A
                const boardAfterA = JSON.parse(JSON.stringify(board));
                boardAfterA[a.to[0]][a.to[1]] = boardAfterA[a.from[0]][a.from[1]];
                boardAfterA[a.from[0]][a.from[1]] = '';
                // Simula o movimento da torre no roque para A, se aplicável
                if (a.piece.toLowerCase() === 'k' && Math.abs(a.to[1] - a.from[1]) === 2) {
                    let rookOriginalColA = (a.to[1] > a.from[1]) ? 7 : 0;
                    let rookFinalColA = (a.to[1] > a.from[1]) ? a.from[1] + 1 : a.from[1] - 1;
                    const rookPieceA = boardAfterA[a.from[0]][rookOriginalColA];
                    boardAfterA[a.from[0]][rookFinalColA] = rookPieceA;
                    boardAfterA[a.from[0]][rookOriginalColA] = '';
                }
                // Promoção de Peão no tabuleiro simulado para A (IA sempre promove para Rainha)
                if (a.piece.toLowerCase() === 'p') {
                    if ((isWhitePiece(a.piece) && a.to[0] === 0) || (isBlackPiece(a.piece) && a.to[0] === 7)) {
                        // Para classificação, assume temporariamente a promoção para rainha para uma verificação rápida
                        boardAfterA[a.to[0]][a.to[1]] = isWhitePiece(a.piece) ? 'Q' : 'q';
                    }
                }

                // Define temporariamente o jogador atual para preto para isKingInCheck
                const originalCurrentPlayer = currentPlayer;
                currentPlayer = 'black';
                const aGivesCheck = isKingInCheck('white', boardAfterA); // Verifica se o rei branco está em xeque
                currentPlayer = originalCurrentPlayer; // Reverte

                // Simula o tabuleiro para o movimento B
                const boardAfterB = JSON.parse(JSON.stringify(board));
                boardAfterB[b.to[0]][b.to[1]] = boardAfterB[b.from[0]][b.from[1]];
                boardAfterB[b.from[0]][b.from[1]] = '';
                // Simula o movimento da torre no roque para B, se aplicável
                if (b.piece.toLowerCase() === 'k' && Math.abs(b.to[1] - b.from[1]) === 2) {
                    let rookOriginalColB = (b.to[1] > b.from[1]) ? 7 : 0;
                    let rookFinalColB = (b.to[1] > b.from[1]) ? b.from[1] + 1 : b.from[1] - 1;
                    const rookPieceB = boardAfterB[b.from[0]][rookOriginalColB];
                    boardAfterB[b.from[0]][rookFinalColB] = rookPieceB;
                    boardAfterB[b.from[0]][rookOriginalColB] = '';
                }
                // Promoção de Peão no tabuleiro simulado para B (IA sempre promove para Rainha)
                if (b.piece.toLowerCase() === 'p') {
                    if ((isWhitePiece(b.piece) && b.to[0] === 0) || (isBlackPiece(b.piece) && b.to[0] === 7)) {
                        // Para classificação, assume temporariamente a promoção para rainha para uma verificação rápida
                        boardAfterB[b.to[0]][b.to[1]] = isWhitePiece(b.piece) ? 'Q' : 'q';
                    }
                }

                // Define temporariamente o jogador atual para preto para isKingInCheck
                currentPlayer = 'black';
                const bGivesCheck = isKingInCheck('white', boardAfterB); // Verifica se o rei branco está em xeque
                currentPlayer = originalCurrentPlayer; // Reverte

                if (aGivesCheck && !bGivesCheck) return -1; // A é melhor se der xeque e B não
                if (!aGivesCheck && bGivesCheck) return 1;  // B é melhor se der xeque e A não

                // Caso contrário, mantém a ordem original (aleatoriedade)
                return 0;
            });


            console.log("IA considerando movimentos:"); // Log de depuração
            for (const move of allPossibleMoves) {
                const { from: [fromR, fromC], to: [toR, toC], piece, capturedPiece, capturedPieceValue } = move;

                // Simula o movimento em um tabuleiro temporário
                const newBoard = JSON.parse(JSON.stringify(board));
                const originalPiece = newBoard[fromR][fromC];
                const simulatedCapturedPiece = newBoard[toR][toC]; // Peça que seria capturada na simulação

                newBoard[toR][toC] = originalPiece;
                newBoard[fromR][fromC] = '';

                // Promoção de Peão no tabuleiro simulado para a chamada minimax
                let simulatedMovedPiece = originalPiece;
                if (originalPiece.toLowerCase() === 'p') {
                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                    }
                }


                // Simula a atualização das flags de roque para a chamada minimax
                const simulatedCastlingFlags = {
                    whiteKingMoved: whiteKingMoved,
                    blackKingMoved: blackKingMoved,
                    whiteRookLeftMoved: whiteRookLeftMoved,
                    whiteRookRightMoved: whiteRookRightMoved,
                    blackRookLeftMoved: blackRookLeftMoved,
                    blackRookRightMoved: blackRookRightMoved
                };
                if (originalPiece === 'K') simulatedCastlingFlags.whiteKingMoved = true;
                if (originalPiece === 'k') simulatedCastlingFlags.blackKingMoved = true;
                if (originalPiece === 'R' && fromR === 7 && fromC === 0) simulatedCastlingFlags.whiteRookLeftMoved = true;
                if (originalPiece === 'R' && fromR === 7 && fromC === 7) simulatedCastlingFlags.whiteRookRightMoved = true;
                if (originalPiece === 'r' && fromR === 0 && fromC === 0) simulatedCastlingFlags.blackRookLeftMoved = true;
                if (originalPiece === 'r' && fromR === 0 && fromC === 7) simulatedCastlingFlags.blackRookRightMoved = true;


                // Se for um movimento de roque, também move a torre no tabuleiro simulado
                if (piece.toLowerCase() === 'k' && Math.abs(toC - fromC) === 2) {
                    let rookOriginalCol;
                    if (toC > fromC) { // Roque do lado do rei
                        rookOriginalCol = 7;
                    } else { // Roque do lado da rainha
                        rookOriginalCol = 0;
                    }
                    const rookPiece = newBoard[fromR][rookOriginalCol];
                    let rookFinalCol;
                    if (toC > fromC) { // Roque do lado do rei
                        rookFinalCol = fromC + 1;
                    } else { // Roque do lado da rainha
                        rookFinalCol = fromC - 1;
                    }
                    newBoard[fromR][rookFinalCol] = rookPiece;
                    newBoard[fromR][rookOriginalCol] = '';
                }

                // Chama minimax com alpha e beta e flags de roque atuais
                const evaluation = minimax(newBoard, searchDepth - 1, false, -Infinity, Infinity, simulatedCastlingFlags);

                let moveDescription = `  Movimento: ${String.fromCharCode(97 + fromC)}${8 - fromR} -> ${String.fromCharCode(97 + toC)}${8 - toR} (Peça: ${piece})`;
                if (capturedPiece) {
                    moveDescription += `, CAPTURA: ${capturedPiece} (Valor: ${capturedPieceValue})`;
                } else {
                    moveDescription += `, Sem Captura`;
                }
                moveDescription += `, Avaliação: ${evaluation}`;
                console.log(moveDescription);

                if (evaluation > maxEval) {
                    maxEval = evaluation;
                    bestMove = move;
                } else if (evaluation === maxEval) {
                    // Se as avaliações forem iguais, prefere movimentos que capturam peças de maior valor
                    // Esta lógica agora é tratada pela classificação inicial.
                    // Mantém um desempate aleatório para movimentos verdadeiramente idênticos
                    if (Math.random() < 0.5) {
                        bestMove = move;
                    }
                }
            }

            if (bestMove) {
                // Executa o melhor movimento encontrado
                const { from: [fromR, fromC], to: [toR, toC], piece } = bestMove;
                console.log(`Melhor movimento escolhido: ${String.fromCharCode(97 + fromC)}${8 - fromR} -> ${String.fromCharCode(97 + toC)}${8 - toR}, Avaliação Máxima: ${maxEval}`); // Log de depuração

                // Determina a peça final para promoção se for uma promoção de peão
                let finalPromotedPiece = null;
                if (piece.toLowerCase() === 'p' && ((isWhitePiece(piece) && toR === 0) || (isBlackPiece(piece) && toR === 7))) {
                    finalPromotedPiece = decidePromotionPieceForAI(board, toR, toC, isWhitePiece(piece));
                }

                // Lida com o roque como um caso especial para a atualização do tabuleiro real
                if (piece.toLowerCase() === 'k' && Math.abs(toC - fromC) === 2) {
                    let rookOriginalCol;
                    if (toC > fromC) { // Roque do lado do rei
                        rookOriginalCol = 7;
                    } else { // Roque do lado da rainha
                        rookOriginalCol = 0;
                    }
                    makeCastlingMove(fromR, fromC, toR, rookOriginalCol);
                } else {
                    makeMove(fromR, fromC, toR, toC, finalPromotedPiece);
                }

                deselectPiece(); // Garante que nenhuma peça esteja selecionada após o movimento da IA
                switchPlayer(); // Troca para o próximo jogador (humano)
                saveCurrentState(); // Salva o movimento da IA no histórico
            } else {
                // Se nenhum melhor movimento for encontrado (ex: empate por afogamento ou xeque-mate detectado pela IA)
                console.warn("A IA não conseguiu encontrar um movimento. Isso pode indicar empate por afogamento ou xeque-mate.");
                // O estado do jogo já deve ser atualizado por switchPlayer se for xeque-mate/empate por afogamento
            }
            isThinking = false;
            updateHistoryButtons();
            updateStatus();
        }

        // Listeners de eventos para os botões
        resetButton.addEventListener('click', () => initializeNewGame(gameMode)); // Reset irá reinicializar no modo atual
        undoButton.addEventListener('click', undoMove);
        redoButton.addEventListener('click', redoMove);
        backToMenuButton.addEventListener('click', showMainMenu); // Ainda apenas mostra o menu principal
        playVsComputerBtn.addEventListener('click', () => startGameMode('computer')); // Chama a nova função startGameMode
        playVsPlayerBtn.addEventListener('click', () => startGameMode('player')); // Chama a nova função startGameMode

        // Inicializa o jogo sempre mostrando o menu principal primeiro
        document.addEventListener('DOMContentLoaded', () => {
            initializeZobristTable(); // Inicializa a tabela Zobrist uma vez ao carregar
            showMainMenu(); // Sempre inicia no menu principal
        });
    </script>
</body>
</html>
