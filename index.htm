<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Xadrez</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Fundo escuro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0; /* Texto claro */
            padding: 20px; /* Preenchimento ao redor de toda a área do jogo */
            box-sizing: border-box;
            overflow-x: hidden; /* Garante que não haja rolagem horizontal */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748; /* Fundo escuro ligeiramente mais claro para o contêiner */
            padding: 20px; /* Preenchimento dentro do contêiner do jogo, ao redor do tabuleiro e botões */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border: 4px solid #4a5568; /* Borda movida para cá */
            box-sizing: border-box; /* Inclui preenchimento e borda no cálculo da largura */
            /* Define uma largura máxima para o contêiner do jogo em telas maiores */
            /* Isso deve acomodar o tamanho máximo do tabuleiro (480px) + seu próprio preenchimento (2*20px) + sua própria borda (2*4px) */
            max-width: 528px; /* 480px (tamanho máximo do tabuleiro) + 2*20px (preenchimento do contêiner) + 2*4px (borda do contêiner) = 528px */
            width: 100%; /* Ocupa toda a largura disponível até a largura máxima */
            position: relative; /* Necessário para o posicionamento absoluto do modal de promoção */
        }

        .chessboard {
            /* O tabuleiro agora ocupará 100% da largura disponível dentro do preenchimento do seu pai */
            width: 100%;
            /* Deixa o JavaScript ajustar a altura para manter o aspecto quadrado */
            height: auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr); /* Cada coluna ocupa uma fração igual do espaço disponível */
            grid-template-rows: repeat(8, 1fr); /* Cada linha ocupa uma fração igual */
            /* Borda e raio da borda removidos daqui */
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
        }

        .square {
            /* Estes serão definidos dinamicamente pelo JS para garantir que os quadrados sejam quadrados */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px; /* Padrão, será ajustado pela media query */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .light {
            background-color: #f0d9b5; /* Cor clara do quadrado */
        }

        .dark {
            background-color: #b58863; /* Cor escura do quadrado */
        }

        .selected {
            background-color: #6ee7b7 !important; /* Esverdeado para peça selecionada */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
        }

        .possible-move {
            background-color: #93c5fd !important; /* Azulado para movimentos possíveis */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
        }

        .piece {
            cursor: grab;
            font-size: 38px; /* Ligeiramente maior para melhor visibilidade */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s ease-out;
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .white-piece {
            color: #f7fafc; /* Cor da peça branca */
        }

        .black-piece {
            color: #2d3748; /* Cor da peça preta */
        }

        .status-message {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: #a0aec0; /* Cinza mais claro para o status */
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap; /* Permite que os botões quebrem em telas menores */
            justify-content: center; /* Centraliza os botões quando quebrados */
        }

        .game-button {
            background-color: #4299e1; /* Botão azul */
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
        }

        .game-button:hover:not(:disabled) {
            background-color: #3182ce; /* Azul mais escuro ao passar o mouse */
            transform: translateY(-2px);
        }

        .game-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .game-button:disabled {
            background-color: #6b7280; /* Cinza para desabilitado */
            cursor: not-allowed;
            opacity: 0.7;
        }

        .main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 100%;
            text-align: center;
        }

        .menu-button {
            background-color: #48bb78; /* Botão verde */
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.3rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
            width: 80%;
            margin-bottom: 20px;
        }

        .menu-button:hover {
            background-color: #38a169; /* Verde mais escuro ao passar o mouse */
            transform: translateY(-3px);
        }

        .menu-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* O seletor de dificuldade agora está oculto */
        .difficulty-selector {
            display: none; /* Oculta todo o seletor de dificuldade */
        }

        /* Modal de Promoção de Peão */
        .promotion-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            border: 2px solid #4a5568;
        }

        .promotion-modal h3 {
            font-size: 1.8rem;
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 10px;
        }

        .promotion-options {
            display: flex;
            gap: 15px;
        }

        .promotion-button {
            background-color: #48bb78; /* Botão verde */
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 2.5rem; /* Tamanho grande do ícone */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
            width: 70px; /* Largura fixa para tamanho de botão consistente */
            height: 70px; /* Altura fixa */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .promotion-button:hover {
            background-color: #38a169; /* Verde mais escuro ao passar o mouse */
            transform: translateY(-3px);
        }

        .promotion-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Ajustes responsivos para o modal de promoção e layout geral */
        @media (max-width: 600px) {
            body {
                padding: 10px; /* Reduz o preenchimento do corpo em telas pequenas */
            }
            .game-container {
                padding: 10px; /* Reduz o preenchimento do contêiner em telas pequenas */
                border-radius: 10px; /* Raio da borda ligeiramente menor */
                max-width: 100%; /* Garante que ele possa encolher completamente */
                width: calc(100% - 20px); /* Considera o novo preenchimento do corpo */
            }
            .chessboard {
                width: 100%; /* Mantém 100% */
                height: auto; /* Deixa o JS lidar com a altura para mantê-lo quadrado */
            }
            .square {
                font-size: 28px; /* Tamanho menor da peça no celular */
            }
            .piece {
                font-size: 30px; /* Tamanho menor da peça no celular */
            }
            .status-message {
                font-size: 1.2rem; /* Mensagem de status menor no celular */
            }
            .control-buttons {
                gap: 10px; /* Reduz a lacuna entre os botões */
            }
            .game-button, .menu-button {
                padding: 10px 20px;
                font-size: 1rem;
                width: auto; /* Permite que os botões se ajustem naturalmente */
                flex-grow: 1; /* Permite que cresçam se o espaço permitir */
            }
            .promotion-modal {
                padding: 15px;
                width: 90%;
            }
            .promotion-modal h3 {
                font-size: 1.4rem;
            }
            .promotion-options {
                flex-wrap: wrap;
                justify-content: center;
            }
            .promotion-button {
                width: 55px;
                height: 55px;
                font-size: 2rem;
                padding: 10px;
            }
        }
    </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-5">
    <!-- Seção do Menu Principal -->
    <div id="mainMenu" class="main-menu">
        <h1 class="text-4xl font-bold mb-8 text-white">Jogo de Xadrez</h1>
        <!-- A dificuldade agora é fixa em "Normal (Recomendado)" e a seleção foi removida do UI -->
        <!-- O valor de aiSearchDepth será definido diretamente no JavaScript para 2 -->
        <button id="playVsComputerBtn" class="menu-button">Um Jogador</button>
        <button id="playVsPlayerBtn" class="menu-button">Dois Jogadores</button>
        <!-- O botão "Limpar Partida Salva" foi removido -->
    </div>

    <!-- Seção do Contêiner do Jogo (inicialmente oculta) -->
    <div id="gameContainer" class="game-container hidden">
        <!-- Removido o título "Jogo de Xadrez" da tela de jogo -->
        <div id="status" class="status-message">Vez das Brancas</div>
        <div id="chessboard" class="chessboard"></div>
        <div class="control-buttons">
            <button id="undoButton" class="game-button">Voltar Jogada</button>
            <button id="redoButton" class="game-button">Prosseguir Jogada</button>
            <button id="resetButton" class="game-button">Reiniciar Jogo</button>
            <button id="backToMenuButton" class="game-button">Voltar ao Menu</button>
        </div>

        <!-- Modal de Promoção de Peão (inicialmente oculto) -->
        <div id="promotionModal" class="promotion-modal hidden">
            <h3>Escolha a peça para promoção:</h3>
            <div class="promotion-options" id="promotionOptions">
                <!-- Os botões de promoção serão inseridos aqui pelo JavaScript -->
            </div>
        </div>
    </div>

    <script type="module">
        // Caracteres Unicode das peças de xadrez
        const PIECES = {
            'K': '&#9812;', 'Q': '&#9813;', 'R': '&#9814;', 'B': '&#9815;', 'N': '&#9816;', 'P': '&#9817;', // Brancas
            'k': '&#9818;', 'q': '&#9819;', 'r': '&#9820;', 'b': '&#9821;', 'n': '&#9822;', 'p': '&#9823;'  // Pretas
        };

        // Configuração inicial do tabuleiro (representação tipo FEN string)
        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let board = []; // Estado atual do tabuleiro
        let selectedPiece = null; // Armazena a posição da peça atualmente selecionada [linha, coluna]
        let currentPlayer = 'white'; // 'white' ou 'black'
        let gameOver = false;
        let gameMode = 'player'; // 'player' ou 'computer'
        let isThinking = false; // Flag para impedir a entrada do usuário enquanto a IA está pensando
        let aiSearchDepth = 2; // Profundidade de busca da IA padrão (Normal) - agora fixa

        // Flags de roque
        let whiteKingMoved = false;
        let blackKingMoved = false;
        let whiteRookLeftMoved = false; // Torre em (7,0)
        let whiteRookRightMoved = false; // Torre em (7,7)
        let blackRookLeftMoved = false; // Torre em (0,0)
        let blackRookRightMoved = false; // Torre em (0,7)

        let gameHistory = []; // Array para armazenar estados anteriores do jogo
        let historyPointer = -1; // Índice do estado atual no gameHistory

        let promotionTarget = null; // Armazena [linha, coluna] para promoção de peão

        const mainMenuElement = document.getElementById('mainMenu');
        const gameContainerElement = document.getElementById('gameContainer');
        const chessboardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const backToMenuButton = document.getElementById('backToMenuButton');
        const playVsComputerBtn = document.getElementById('playVsComputerBtn');
        const playVsPlayerBtn = document.getElementById('playVsPlayerBtn');
        const promotionModal = document.getElementById('promotionModal');
        const promotionOptions = document.getElementById('promotionOptions');

        // Valores das peças para a função de avaliação (Sinais corrigidos para a perspectiva da IA - Preto é o jogador maximizador)
        const PIECE_VALUES = {
            'P': -20000,  // Peão Branco: -1 ponto (negativo porque é ruim para o preto)
            'N': -70000,  // Cavalo Branco: -3.5 pontos
            'B': -70000,  // Bispo Branco: -3.5 pontos
            'R': -120000, // Torre Branca: -6 pontos
            'Q': -220000, // Rainha Branca: -11 pontos
            'K': -1000000000, // Rei Branco: Inestimável (grande negativo para evitar a captura do rei)

            'p': 20000,   // Peão Preto: +1 ponto (positivo porque é bom para o preto)
            'n': 70000,   // Cavalo Preto: +3.5 pontos
            'b': 70000,   // Bispo Preto: +3.5 pontos
            'r': 120000,  // Torre Preta: +6 pontos
            'q': 220000, // Rainha Preta: +11 pontos
            'k': 1000000000 // Rei Preto: Inestimável
        };

        // Tabelas de posição das peças (exemplo, pode ser refinado)
        // Os valores são adicionados ao valor base da peça. Positivo para branco, negativo para preto.
        const PAWN_POSITION_TABLE = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [5, 5, 10, 25, 25, 10, 5, 5],
            [0, 0, 0, 20, 20, 0, 0, 0],
            [5, -5, -10, 0, 0, -10, -5, 5],
            [5, 10, 10, -20, -20, 10, 10, 5],
            [0, 0, 0, 0, 0, 0, 0, 0]
        ];

        const KNIGHT_POSITION_TABLE = [
            [-50, -40, -30, -30, -30, -30, -40, -50],
            [-40, -20, 0, 0, 0, 0, -20, -40],
            [-30, 0, 10, 15, 15, 10, 0, -30],
            [-30, 5, 15, 20, 20, 15, 5, -30],
            [-30, 0, 15, 20, 20, 15, 0, -30],
            [-30, 5, 10, 15, 15, 10, 5, -30],
            [-40, -20, 0, 5, 5, 0, -20, -40],
            [-50, -40, -30, -30, -30, -30, -30, -50]
        ];

        const BISHOP_POSITION_TABLE = [
            [-20, -10, -10, -10, -10, -10, -10, -20],
            [-10, 0, 0, 0, 0, 0, 0, -10],
            [-10, 0, 5, 10, 10, 5, 0, -10],
            [-10, 5, 5, 10, 10, 5, 5, -10],
            [-10, 0, 10, 10, 10, 10, 0, -10],
            [-10, 10, 10, 10, 10, 10, 10, -10],
            [-10, 5, 0, 0, 0, 0, 5, -10],
            [-20, -10, -10, -10, -10, -10, -10, -20]
        ];

        const ROOK_POSITION_TABLE = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [5, 10, 10, 10, 10, 10, 10, 5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [0, 0, 0, 5, 5, 0, 0, 0]
        ];

        const QUEEN_POSITION_TABLE = [
            [-20, -10, -10, -5, -5, -10, -10, -20],
            [-10, 0, 0, 0, 0, 0, 0, -10],
            [-10, 0, 5, 5, 5, 5, 0, -10],
            [-5, 0, 5, 5, 5, 5, 0, -5],
            [0, 0, 5, 5, 5, 5, 0, -5],
            [-10, 5, 5, 5, 5, 5, 0, -10],
            [-10, 0, 5, 0, 0, 0, 0, -10],
            [-20, -10, -10, -5, -5, -10, -10, -20]
        ];

        const KING_POSITION_TABLE_MIDDLE_GAME = [
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-20, -30, -30, -40, -40, -30, -30, -20],
            [-10, -20, -20, -20, -20, -20, -20, -10],
            [20, 20, 0, 0, 0, 0, 20, 20],
            [20, 30, 10, 0, 0, 10, 30, 20]
        ];

        const KING_POSITION_TABLE_END_GAME = [
            [-50, -40, -30, -20, -20, -30, -40, -50],
            [-30, -20, -10, 0, 0, -10, -20, -30],
            [-30, -10, 20, 30, 30, 20, -10, -30],
            [-30, -10, 30, 40, 40, 30, -10, -30],
            [-30, -10, 30, 40, 40, 30, -10, -30],
            [-30, -10, 20, 30, 30, 20, -10, -30],
            [-30, -20, -10, 0, 0, -10, -20, -30],
            [-50, -40, -30, -20, -20, -30, -40, -50]
        ];


        // --- Zobrist Hashing e Tabela de Transposição ---
        const ZOBRIST_TABLE = {};
        let currentZobristHash = 0;
        const transpositionTable = new Map(); // Armazena {hash: {evaluation, depth, bestMove}}

        /**
         * Gera um inteiro aleatório de 32 bits.
         * @returns {number} Um inteiro aleatório de 32 bits.
         */
        function getRandom32BitInt() {
            return (Math.random() * 0x100000000) | 0; // Gera um inteiro de 32 bits
        }

        /**
         * Inicializa a tabela Zobrist com números aleatórios para cada peça em cada quadrado.
         * Também inicializa números aleatórios para direitos de roque, arquivo en passant e turno.
         */
        function initializeZobristTable() {
            // Peças nos quadrados
            for (const pieceType in PIECES) {
                ZOBRIST_TABLE[pieceType] = [];
                for (let r = 0; r < 8; r++) {
                    ZOBRIST_TABLE[pieceType][r] = [];
                    for (let c = 0; c < 8; c++) {
                        ZOBRIST_TABLE[pieceType][r][c] = getRandom32BitInt();
                    }
                }
            }

            // Direitos de roque (Rei Branco, Rainha Branca, Rei Preto, Rainha Preta)
            ZOBRIST_TABLE.castling = {
                'WK': getRandom32BitInt(),
                'WQ': getRandom32BitInt(),
                'BK': getRandom32BitInt(),
                'BQ': getRandom32BitInt()
            };

            // Para mover (Branco ou Preto)
            ZOBRIST_TABLE.turn = {
                'white': getRandom32BitInt(),
                'black': getRandom32BitInt()
            };
            // Nota: En passant não está totalmente implementado em Zobrist para simplificar nesta versão.
        }

        /**
         * Calcula o hash Zobrist para um determinado estado do tabuleiro.
         * Esta função deve ser usada no início do minimax para fazer o hash do estado atual do tabuleiro.
         * @param {Array<Array<string>>} boardState - O estado do tabuleiro para fazer o hash.
         * @param {string} playerTurn - O turno do jogador ('white' ou 'black').
         * @param {object} castlingFlags - Objeto com as flags de roque atuais (whiteKingMoved, etc.).
         * @returns {number} O hash Zobrist para o estado do tabuleiro dado.
         */
        function calculateBoardHash(boardState, playerTurn, castlingFlags) {
            let hash = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c];
                    if (piece) {
                        hash ^= ZOBRIST_TABLE[piece][r][c];
                    }
                }
            }

            // Adiciona direitos de roque ao hash
            if (!castlingFlags.whiteKingMoved && !castlingFlags.whiteRookRightMoved) hash ^= ZOBRIST_TABLE.castling['WK'];
            if (!castlingFlags.whiteKingMoved && !castlingFlags.whiteRookLeftMoved) hash ^= ZOBRIST_TABLE.castling['WQ'];
            if (!castlingFlags.blackKingMoved && !castlingFlags.blackRookRightMoved) hash ^= ZOBRIST_TABLE.castling['BK'];
            if (!castlingFlags.blackKingMoved && !castlingFlags.blackRookLeftMoved) hash ^= ZOBRIST_TABLE.castling['BQ'];

            // Adiciona turno ao hash
            hash ^= ZOBRIST_TABLE.turn[playerTurn];

            return hash;
        }

        // --- Fim da Configuração de Hashing Zobrist e Tabela de Transposição ---

        /**
         * Mostra o menu principal e oculta o contêiner do jogo.
         */
        function showMainMenu() {
            mainMenuElement.classList.remove('hidden');
            gameContainerElement.classList.add('hidden');
        }

        /**
         * Mostra o contêiner do jogo e oculta o menu principal.
         */
        function showGame() {
            mainMenuElement.classList.add('hidden');
            gameContainerElement.classList.remove('hidden');
            adjustChessboardSquareSize(); // Chama quando o contêiner do jogo é mostrado
        }

        /**
         * Salva o estado atual do jogo no localStorage.
         */
        function saveGameToLocalStorage() {
            const gameState = {
                board: board,
                currentPlayer: currentPlayer,
                gameOver: gameOver,
                whiteKingMoved: whiteKingMoved,
                blackKingMoved: blackKingMoved,
                whiteRookLeftMoved: whiteRookLeftMoved,
                whiteRookRightMoved: whiteRookRightMoved,
                blackRookLeftMoved: blackRookLeftMoved,
                blackRookRightMoved: blackRookRightMoved,
                gameHistory: gameHistory, // Salva todo o histórico para desfazer/refazer
                historyPointer: historyPointer,
                gameMode: gameMode, // Este será o modo que estava ativo quando salvo
                aiSearchDepth: aiSearchDepth
            };
            try {
                // Usa uma chave específica para o modo de jogo atual
                localStorage.setItem(`chessGame_${gameMode}`, JSON.stringify(gameState));
                console.log(`Estado do jogo para ${gameMode} salvo no localStorage.`);
            } catch (e) {
                console.error('Erro ao salvar o jogo no localStorage:', e);
            }
        }

        /**
         * Carrega o estado do jogo do localStorage para um modo específico.
         * @param {string} modeToLoad - O modo de jogo a ser carregado ('computer' ou 'player').
         * @returns {boolean} True se um jogo foi carregado com sucesso, false caso contrário.
         */
        function loadGameFromLocalStorage(modeToLoad) {
            try {
                const savedGame = localStorage.getItem(`chessGame_${modeToLoad}`);
                if (savedGame) {
                    const gameState = JSON.parse(savedGame);
                    board = gameState.board;
                    currentPlayer = gameState.currentPlayer;
                    gameOver = gameState.gameOver;
                    whiteKingMoved = gameState.whiteKingMoved;
                    blackKingMoved = gameState.blackKingMoved;
                    whiteRookLeftMoved = gameState.whiteRookLeftMoved;
                    whiteRookRightMoved = gameState.whiteRookRightMoved;
                    blackRookLeftMoved = gameState.blackRookLeftMoved;
                    blackRookRightMoved = gameState.blackRookRightMoved;
                    gameHistory = gameState.gameHistory;
                    historyPointer = gameState.historyPointer;
                    gameMode = modeToLoad; // Define o gameMode para o que foi carregado
                    aiSearchDepth = gameState.aiSearchDepth || 2; // Garante que aiSearchDepth seja definido, padrão para 2

                    // Recalcula o hash Zobrist após carregar o tabuleiro
                    currentZobristHash = calculateBoardHash(board, currentPlayer, {
                        whiteKingMoved, blackKingMoved, whiteRookLeftMoved, whiteRookRightMoved, blackRookLeftMoved, blackRookRightMoved
                    });

                    renderBoard();
                    updateStatus();
                    updateHistoryButtons();
                    console.log(`Estado do jogo para ${modeToLoad} carregado do localStorage.`);

                    // Se for o turno da IA após o carregamento, faz o movimento da IA
                    if (!gameOver && gameMode === 'computer' && currentPlayer === 'black') {
                        isThinking = true;
                        statusElement.textContent = "Computador pensando...";
                        updateHistoryButtons();
                        setTimeout(makeComputerMove, 500);
                    }
                    return true; // Jogo carregado com sucesso
                }
            } catch (e) {
                console.error('Erro ao carregar o jogo do localStorage:', e);
                localStorage.removeItem(`chessGame_${modeToLoad}`); // Limpa dados corrompidos para aquele modo
            }
            return false; // Nenhum jogo carregado
        }

        /**
         * Inicializa um novo tabuleiro de jogo e o renderiza para um modo específico.
         * Esta função sempre inicia um novo jogo, descartando qualquer estado anterior para aquele modo.
         * @param {string} mode - 'computer' ou 'player'
         */
        function initializeNewGame(mode) {
            board = JSON.parse(JSON.stringify(initialBoard)); // Cópia profunda do tabuleiro inicial
            selectedPiece = null;
            currentPlayer = 'white';
            gameOver = false;
            gameMode = mode; // Define o modo de jogo
            isThinking = false; // Reseta a flag de pensamento
            aiSearchDepth = 2; // Profundidade de busca da IA fixa para Normal (2)

            // Reseta as flags de roque
            whiteKingMoved = false;
            blackKingMoved = false;
            whiteRookLeftMoved = false;
            whiteRookRightMoved = false;
            blackRookLeftMoved = false;
            blackRookRightMoved = false;

            gameHistory = []; // Limpa o histórico
            historyPointer = -1; // Reseta o ponteiro
            transpositionTable.clear(); // Limpa a tabela de transposição para um novo jogo

            // A tabela Zobrist é inicializada uma vez no DOMContentLoaded, não é necessário reinicializar aqui
            // Recalcula o hash inicial com base no estado inicial do tabuleiro e nas flags
            currentZobristHash = calculateBoardHash(board, currentPlayer, {
                whiteKingMoved, blackKingMoved, whiteRookLeftMoved, whiteRookRightMoved, blackRookLeftMoved, blackRookRightMoved
            });

            saveCurrentState(); // Salva este novo estado inicial
            renderBoard();
            updateStatus();
            updateHistoryButtons();

            // Se estiver começando contra o computador, e for o turno do preto (turno da IA), faz o movimento da IA
            if (gameMode === 'computer' && currentPlayer === 'black') {
                setTimeout(makeComputerMove, 500); // Pequeno atraso para melhor UX
            }
        }

        /**
         * Inicia um jogo em um modo específico. Tenta carregar um jogo salvo para aquele modo primeiro.
         * Se nenhum jogo salvo existir, inicializa um novo.
         * @param {string} mode - 'computer' ou 'player'
         */
        function startGameMode(mode) {
            if (!loadGameFromLocalStorage(mode)) { // Tenta carregar
                initializeNewGame(mode); // Se nenhum jogo salvo, inicia um novo
            }
            showGame(); // Sempre mostra o tabuleiro após tentar carregar/inicializar
        }


        /**
         * Salva o estado atual do jogo no histórico.
         * Se novos movimentos forem feitos após desfazer, isso trunca o histórico "futuro".
         */
        function saveCurrentState() {
            // Se desfizemos movimentos, trunca o histórico para o ponteiro atual
            if (historyPointer < gameHistory.length - 1) {
                gameHistory = gameHistory.slice(0, historyPointer + 1);
            }
            gameHistory.push({
                board: JSON.parse(JSON.stringify(board)), // Cópia profunda do tabuleiro
                currentPlayer: currentPlayer,
                gameOver: gameOver,
                whiteKingMoved: whiteKingMoved,
                blackKingMoved: blackKingMoved,
                whiteRookLeftMoved: whiteRookLeftMoved,
                whiteRookRightMoved: whiteRookRightMoved,
                blackRookLeftMoved: blackRookLeftMoved,
                blackRookRightMoved: blackRookRightMoved,
                zobristHash: currentZobristHash // Salva o hash Zobrist atual
            });
            historyPointer++;
            updateHistoryButtons();
            saveGameToLocalStorage(); // Salva no localStorage após cada mudança de estado
        }

        /**
         * Carrega um estado de jogo específico do histórico.
         * @param {number} index - O índice do estado a ser carregado.
         */
        function loadState(index) {
            if (index >= 0 && index < gameHistory.length) {
                const state = gameHistory[index];
                board = JSON.parse(JSON.stringify(state.board));
                currentPlayer = state.currentPlayer;
                gameOver = state.gameOver;
                whiteKingMoved = state.whiteKingMoved;
                blackKingMoved = state.blackKingMoved;
                whiteRookLeftMoved = state.whiteRookLeftMoved;
                whiteRookRightMoved = state.whiteRookRightMoved;
                blackRookLeftMoved = state.blackRookLeftMoved;
                blackRookRightMoved = state.blackRookRightMoved;
                currentZobristHash = state.zobristHash; // Carrega o hash Zobrist

                selectedPiece = null; // Desseleciona qualquer peça ao carregar o estado
                renderBoard();
                updateStatus();
                updateHistoryButtons();
                saveGameToLocalStorage(); // Salva no localStorage após carregar um estado histórico
            }
        }

        /**
         * Desfaz o último movimento.
         */
        function undoMove() {
            if (historyPointer > 0) {
                historyPointer--;
                loadState(historyPointer);
            }
        }

        /**
         * Refaz um movimento previamente desfeito.
         */
        function redoMove() {
            if (historyPointer < gameHistory.length - 1) {
                historyPointer++;
                loadState(historyPointer);
            }
        }

        /**
         * Atualiza o estado habilitado/desabilitado dos botões de desfazer/refazer.
         */
        function updateHistoryButtons() {
            undoButton.disabled = historyPointer <= 0 || isThinking;
            redoButton.disabled = historyPointer >= gameHistory.length - 1 || isThinking;
            // Também desabilita toda a interação do tabuleiro se o jogo acabou ou a IA está pensando ou o modal de promoção está aberto
            if (gameOver || isThinking || !promotionModal.classList.contains('hidden')) {
                chessboardElement.style.pointerEvents = 'none';
            } else {
                chessboardElement.style.pointerEvents = 'auto';
            }
        }

        /**
         * Ajusta o tamanho dos quadrados do tabuleiro para manter uma proporção quadrada.
         */
        function adjustChessboardSquareSize() {
            const chessboardWidth = chessboardElement.offsetWidth;
            const squareSize = chessboardWidth / 8; // Calcula o tamanho com base na largura atual do tabuleiro

            // Aplica o tamanho calculado a cada quadrado
            document.querySelectorAll('.square').forEach(square => {
                square.style.width = `${squareSize}px`;
                square.style.height = `${squareSize}px`;
            });
        }

        /**
         * Renderiza o tabuleiro com base no estado 'board' atual.
         */
        function renderBoard() {
            chessboardElement.innerHTML = ''; // Limpa o tabuleiro existente
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.classList.add('square', (row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const piece = board[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.classList.add('piece', isWhitePiece(piece) ? 'white-piece' : 'black-piece');
                        pieceElement.innerHTML = PIECES[piece];
                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', handleSquareClick);
                    chessboardElement.appendChild(square);
                }
            }
            adjustChessboardSquareSize(); // Chama após a renderização
        }

        /**
         * Lida com um evento de clique em um quadrado do tabuleiro.
         * @param {Event} event - O evento de clique.
         */
        function handleSquareClick(event) {
            // Impede movimentos se o jogo acabou ou a IA está pensando ou o modal de promoção está aberto
            if (gameOver || isThinking || !promotionModal.classList.contains('hidden')) return;

            const targetSquare = event.currentTarget;
            const row = parseInt(targetSquare.dataset.row);
            const col = parseInt(targetSquare.dataset.col);
            const pieceAtSquare = board[row][col];

            // Se uma peça já estiver selecionada
            if (selectedPiece) {
                const [prevRow, prevCol] = selectedPiece;
                const prevPiece = board[prevRow][prevCol];

                // Se clicar na mesma peça selecionada, deseleciona-a
                if (row === prevRow && col === prevCol) {
                    deselectPiece();
                    return;
                }

                // Verifica a tentativa de roque (Rei selecionado, alvo é um quadrado de destino de roque)
                if (prevPiece.toLowerCase() === 'k') {
                    let rookCol = -1; // Inicializa com uma coluna inválida

                    // Roque do lado do rei (Rei se move para g1/g8)
                    if ((isWhitePiece(prevPiece) && prevRow === 7 && prevCol === 4 && row === 7 && col === 6) ||
                        (isBlackPiece(prevPiece) && prevRow === 0 && prevCol === 4 && row === 0 && col === 6)) {
                        rookCol = 7; // Coluna da torre do lado do rei
                    }
                    // Roque do lado da rainha (Rei se move para c1/c8)
                    else if ((isWhitePiece(prevPiece) && prevRow === 7 && prevCol === 4 && row === 7 && col === 2) ||
                             (isBlackPiece(prevPiece) && prevRow === 0 && prevCol === 4 && row === 0 && col === 2)) {
                        rookCol = 0; // Coluna da torre do lado da rainha
                    }

                    if (rookCol !== -1) { // Se for um quadrado de destino de roque
                        if (isValidCastling(prevRow, prevCol, row, rookCol)) { // Passa a linha de destino do rei e a coluna original da torre
                            makeCastlingMove(prevRow, prevCol, row, rookCol);
                            deselectPiece();
                            switchPlayer();
                            saveCurrentState();
                            return; // Movimento de roque foi feito, sai do manipulador
                        }
                    }
                }

                // Tenta mover a peça selecionada (movimento regular)
                if (isValidMove(prevPiece, prevRow, prevCol, row, col)) {
                    makeMove(prevRow, prevCol, row, col);
                    // Verifica a promoção de peão após fazer o movimento
                    if (prevPiece.toLowerCase() === 'p' && ((isWhitePiece(prevPiece) && row === 0) || (isBlackPiece(prevPiece) && row === 7))) {
                        promotionTarget = [row, col]; // Armazena o quadrado de destino para promoção
                        showPromotionModal(isWhitePiece(prevPiece));
                    } else {
                        deselectPiece();
                        switchPlayer();
                        saveCurrentState(); // Salva o estado após um movimento válido e troca de jogador
                    }
                } else {
                    // Se clicar em uma nova peça da cor do jogador atual, seleciona-a
                    if (pieceAtSquare && isCurrentPlayerPiece(pieceAtSquare)) {
                        deselectPiece(); // Desseleciona a anterior primeiro
                        selectPiece(row, col);
                    } else {
                        // Movimento inválido ou clicando na peça do oponente sem movimento válido
                        deselectPiece();
                    }
                }
            } else {
                // Nenhuma peça selecionada ainda, tenta selecionar uma
                if (pieceAtSquare && isCurrentPlayerPiece(pieceAtSquare)) {
                    selectPiece(row, col);
                }
            }
        }

        /**
         * Exibe o modal de promoção de peão.
         * @param {boolean} isWhitePawn - True se o peão for branco, false se for preto.
         */
        function showPromotionModal(isWhitePawn) {
            promotionModal.classList.remove('hidden');
            promotionOptions.innerHTML = ''; // Limpa as opções anteriores

            const piecesToPromoteTo = ['Q', 'R', 'B', 'N']; // Rainha, Torre, Bispo, Cavalo
            const pieceColors = isWhitePawn ? piecesToPromoteTo : piecesToPromoteTo.map(p => p.toLowerCase());

            pieceColors.forEach(pieceChar => {
                const button = document.createElement('button');
                button.classList.add('promotion-button');
                button.innerHTML = PIECES[pieceChar];
                button.dataset.piece = pieceChar;
                button.addEventListener('click', () => handlePawnPromotion(pieceChar));
                promotionOptions.appendChild(button);
            });

            // Desabilita a interação do tabuleiro enquanto o modal estiver aberto
            chessboardElement.style.pointerEvents = 'none';
            updateHistoryButtons(); // Atualiza o estado dos botões
        }

        /**
         * Lida com a escolha de promoção de peão.
         * @param {string} chosenPiece - O caractere da peça escolhida (ex: 'Q', 'r').
         */
        function handlePawnPromotion(chosenPiece) {
            if (!promotionTarget) return; // Não deve acontecer

            const [row, col] = promotionTarget;
            const originalPawn = board[row][col]; // Obtém o peão antes da promoção

            // Atualiza o hash Zobrist: XOR do peão, XOR da nova peça
            currentZobristHash ^= ZOBRIST_TABLE[originalPawn][row][col];
            currentZobristHash ^= ZOBRIST_TABLE[chosenPiece][row][col];

            board[row][col] = chosenPiece; // Promove o peão

            promotionModal.classList.add('hidden'); // Oculta o modal
            chessboardElement.style.pointerEvents = 'auto'; // Reabilita a interação do tabuleiro
            promotionTarget = null; // Limpa o alvo de promoção

            renderBoard();
            deselectPiece(); // Garante que nenhuma peça esteja selecionada após a promoção
            switchPlayer(); // Troca para o próximo jogador
            saveCurrentState(); // Salva o estado após a promoção
        }


        /**
         * Seleciona uma peça na linha e coluna dadas.
         * Destaca o quadrado selecionado e os movimentos possíveis.
         * @param {number} row - A linha da peça.
         * @param {number} col - A coluna da peça.
         */
        function selectPiece(row, col) {
            selectedPiece = [row, col];
            const squareElement = chessboardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            squareElement.classList.add('selected');

            // Destaca movimentos possíveis (apenas movimentos legais)
            const piece = board[row][col];
            const legalMoves = getLegalMoves(piece, row, col); // Usa getLegalMoves aqui
            legalMoves.forEach(([r, c]) => {
                chessboardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`).classList.add('possible-move');
            });
        }

        /**
         * Desseleciona a peça atualmente selecionada.
         * Remove os destaques do quadrado selecionado e dos movimentos possíveis.
         */
        function deselectPiece() {
            if (selectedPiece) {
                const [prevRow, prevCol] = selectedPiece;
                chessboardElement.querySelector(`[data-row="${prevRow}"][data-col="${prevCol}"]`).classList.remove('selected');
                selectedPiece = null;
            }
            // Remove todos os destaques de movimentos possíveis
            document.querySelectorAll('.possible-move').forEach(sq => sq.classList.remove('possible-move'));
        }

        /**
         * Verifica se uma peça pertence ao jogador atual.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça pertencer ao jogador atual.
         */
        function isCurrentPlayerPiece(piece) {
            return (currentPlayer === 'white' && isWhitePiece(piece)) ||
                   (currentPlayer === 'black' && isBlackPiece(piece));
        }

        /**
         * Verifica se uma peça é branca.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça for branca.
         */
        function isWhitePiece(piece) {
            return piece === piece.toUpperCase();
        }

        /**
         * Verifica se uma peça é preta.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça for preta.
         */
        function isBlackPiece(piece) {
            return piece === piece.toLowerCase();
        }

        /**
         * Faz um movimento no tabuleiro.
         * @param {number} fromRow - Linha inicial.
         * @param {number} fromCol - Coluna inicial.
         * @param {number} toRow - Linha de destino.
         * @param {number} toCol - Coluna de destino.
         * @param {string} [promotedToPiece] - Opcional: A peça para promover (ex: 'Q', 'n').
         */
        function makeMove(fromRow, fromCol, toRow, toCol, promotedToPiece = null) {
            const movedPiece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol]; // Obtém a peça capturada antes de mover

            // Atualiza as flags de roque
            if (movedPiece === 'K') whiteKingMoved = true;
            if (movedPiece === 'k') blackKingMoved = true;
            if (movedPiece === 'R' && fromRow === 7 && fromCol === 0) whiteRookLeftMoved = true;
            if (movedPiece === 'R' && fromRow === 7 && fromCol === 7) whiteRookRightMoved = true;
            if (movedPiece === 'r' && fromRow === 0 && fromCol === 0) blackRookLeftMoved = true;
            if (movedPiece === 'r' && fromRow === 0 && fromCol === 7) blackRookRightMoved = true;

            // Atualiza o hash Zobrist para o movimento
            currentZobristHash ^= ZOBRIST_TABLE[movedPiece][fromRow][fromCol];
            if (capturedPiece) {
                currentZobristHash ^= ZOBRIST_TABLE[capturedPiece][toRow][toCol]; // XOR da peça capturada
            }

            board[toRow][toCol] = movedPiece; // Move a peça
            board[fromRow][fromCol] = ''; // Limpa a posição original

            // Verificação de Promoção de Peão
            if (movedPiece.toLowerCase() === 'p' && ((isWhitePiece(movedPiece) && toRow === 0) || (isBlackPiece(movedPiece) && toRow === 7))) {
                const finalPromotedPiece = promotedToPiece || (isWhitePiece(movedPiece) ? 'Q' : 'q'); // Padrão para Rainha se não especificado pela IA ou humano
                currentZobristHash ^= ZOBRIST_TABLE[movedPiece][toRow][toCol]; // XOR do peão que acabou de se mover
                currentZobristHash ^= ZOBRIST_TABLE[finalPromotedPiece][toRow][toCol]; // XOR da nova peça promovida
                board[toRow][toCol] = finalPromotedPiece;
            } else {
                currentZobristHash ^= ZOBRIST_TABLE[movedPiece][toRow][toCol]; // XOR da peça movida (se não houver promoção)
            }

            // XOR do turno antigo e XOR do novo turno (apenas se não estiver esperando a promoção humana)
            if (! (movedPiece.toLowerCase() === 'p' && ((isWhitePiece(movedPiece) && toRow === 0) || (isBlackPiece(movedPiece) && toRow === 7)) && !isThinking) ) {
                currentZobristHash ^= ZOBRIST_TABLE.turn[currentPlayer];
                const newPlayer = currentPlayer === 'white' ? 'black' : 'white';
                currentZobristHash ^= ZOBRIST_TABLE.turn[newPlayer];
            }

            renderBoard(); // Renderiza o tabuleiro novamente
        }

        /**
         * Executa um movimento de roque.
         * @param {number} kingStartRow - Linha da posição inicial do Rei.
         * @param {number} kingStartCol - Coluna da posição inicial do Rei.
         * @param {number} kingEndRow - Linha da posição final do Rei (quadrado de roque).
         * @param {number} rookOriginalCol - Coluna original da Torre envolvida no roque.
         */
        function makeCastlingMove(kingStartRow, kingStartCol, kingEndRow, rookOriginalCol) {
            const isWhite = isWhitePiece(board[kingStartRow][kingStartCol]);
            const kingPiece = board[kingStartRow][kingStartCol];
            const rookPiece = board[kingEndRow][rookOriginalCol]; // A Torre está na mesma linha que o rei

            // Atualiza as flags de roque
            if (isWhite) {
                whiteKingMoved = true;
                if (rookOriginalCol === 0) whiteRookLeftMoved = true; // Roque do lado da rainha
                else whiteRookRightMoved = true; // Roque do lado do rei
            } else {
                blackKingMoved = true;
                if (rookOriginalCol === 0) blackRookLeftMoved = true; // Roque do lado da rainha
                else blackRookRightMoved = true; // Roque do lado do rei
            }

            // Determina a coluna final do rei e a coluna final da torre
            let kingFinalCol;
            let rookFinalCol;
            let rookStartCol = rookOriginalCol; // Esta é a coluna inicial real da torre

            if (rookOriginalCol === 7) { // Roque do lado do rei
                kingFinalCol = kingStartCol + 2;
                rookFinalCol = kingStartCol + 1;
            } else { // Roque do lado da rainha (rookOriginalCol === 0)
                kingFinalCol = kingStartCol - 2;
                rookFinalCol = kingStartCol - 1;
            }

            // Atualiza o hash Zobrist para o roque:
            // 1. XOR da posição antiga do rei, XOR da nova posição do rei
            currentZobristHash ^= ZOBRIST_TABLE[kingPiece][kingStartRow][kingStartCol];
            currentZobristHash ^= ZOBRIST_TABLE[kingPiece][kingEndRow][kingFinalCol];
            // 2. XOR da posição antiga da torre, XOR da nova posição da torre
            currentZobristHash ^= ZOBRIST_TABLE[rookPiece][kingEndRow][rookStartCol];
            currentZobristHash ^= ZOBRIST_TABLE[rookPiece][kingEndRow][rookFinalCol];
            // 3. XOR do turno antigo e XOR do novo turno
            currentZobristHash ^= ZOBRIST_TABLE.turn[currentPlayer];
            const newPlayer = currentPlayer === 'white' ? 'black' : 'white';
            currentZobristHash ^= ZOBRIST_TABLE.turn[newPlayer];
            // 4. Também XOR de/para mudanças nos direitos de roque (simplificado por enquanto, mas um Zobrist completo faria isso)


            // Move o Rei
            board[kingEndRow][kingFinalCol] = kingPiece;
            board[kingStartRow][kingStartCol] = '';

            // Move a Torre
            board[kingEndRow][rookFinalCol] = rookPiece;
            board[kingEndRow][rookStartCol] = '';


            renderBoard();
        }


        /**
         * Troca o jogador atual.
         */
        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updateStatus();
            // Verifica xeque-mate/afogamento aqui
            if (isCheckmate(currentPlayer)) {
                gameOver = true;
                statusElement.textContent = `Xeque-mate! ${currentPlayer === 'white' ? 'Pretas' : 'Brancas'} Venceram!`;
            } else if (isStalemate(currentPlayer)) {
                gameOver = true;
                statusElement.textContent = `Empate por Afogamento!`;
            }

            // Se o jogo não acabou e for o turno da IA, faz o movimento da IA
            if (!gameOver && gameMode === 'computer' && currentPlayer === 'black') {
                isThinking = true;
                statusElement.textContent = "Computador pensando...";
                updateHistoryButtons(); // Desabilita os botões enquanto a IA pensa
                setTimeout(makeComputerMove, 500); // Pequeno atraso para melhor UX
            } else {
                isThinking = false;
                updateHistoryButtons(); // Reabilita os botões
            }
        }

        /**
         * Atualiza a mensagem de status exibida ao usuário.
         */
        function updateStatus() {
            if (!gameOver) {
                statusElement.textContent = `Vez das ${currentPlayer === 'white' ? 'Brancas' : 'Pretas'}`;
            } else {
                // Se o jogo acabou, a mensagem de status já está definida por xeque-mate/afogamento
                // Não é necessário alterá-la aqui, a menos que estejamos visualizando um estado anterior.
                if (historyPointer < gameHistory.length - 1) {
                     statusElement.textContent = `Vez das ${gameHistory[historyPointer].currentPlayer === 'white' ? 'Brancas' : 'Pretas'}`;
                }
            }
        }

        /**
         * Verifica se um movimento é válido e legal para uma determinada peça.
         * Esta função também verifica se o movimento coloca ou deixa o rei do jogador atual em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} fromRow - Linha inicial.
         * @param {number} fromCol - Coluna inicial.
         * @param {number} toRow - Linha de destino.
         * @param {number} toCol - Coluna de destino.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {boolean} - True se o movimento for válido e legal.
         */
        function isValidMove(piece, fromRow, fromCol, toRow, toCol, currentBoard = board) {
            // Verificações básicas de limite
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;

            const targetPiece = currentBoard[toRow][toCol];
            const isWhitePieceFn = (p) => p === p.toUpperCase();
            const isBlackPieceFn = (p) => p === p.toLowerCase();
            const isCurrentPlayerPieceFn = (p) => (currentPlayer === 'white' && isWhitePieceFn(p)) || (currentPlayer === 'black' && isBlackPieceFn(p));

            // Não pode capturar sua própria peça
            if (targetPiece && isCurrentPlayerPieceFn(targetPiece)) {
                return false;
            }

            // Obtém os movimentos pseudo-legais para a peça (movimentos baseados no padrão da peça, ignorando a segurança do rei por enquanto)
            const pseudoLegalMoves = getPossibleMoves(piece, fromRow, fromCol, currentBoard);
            const isPseudoLegal = pseudoLegalMoves.some(([r, c]) => r === toRow && c === toCol);

            if (!isPseudoLegal) {
                return false; // Não é um padrão de movimento válido para esta peça
            }

            // --- Crucial: Simula o movimento e verifica a segurança do rei ---
            const originalPiece = currentBoard[fromRow][fromCol];
            const pieceAtTarget = currentBoard[toRow][toCol]; // Armazena o que está no destino

            // Temporariamente faz o movimento no tabuleiro
            currentBoard[toRow][toCol] = originalPiece;
            currentBoard[fromRow][fromCol] = '';

            // Lida com a promoção de peão na simulação para verificação de segurança do rei
            if (originalPiece.toLowerCase() === 'p') {
                if ((isWhitePiece(originalPiece) && toRow === 0) || (isBlackPiece(originalPiece) && toRow === 7)) {
                    // Promove para Rainha para fins de verificação de segurança do rei
                    currentBoard[toRow][toCol] = isWhitePiece(originalPiece) ? 'Q' : 'q';
                }
            }


            // Verifica se o rei *do jogador atual* está em xeque após este movimento simulado
            const kingInCheckAfterMove = isKingInCheck(currentPlayer, currentBoard);

            // Reverte o movimento
            currentBoard[fromRow][fromCol] = originalPiece;
            currentBoard[toRow][toCol] = pieceAtTarget;

            if (kingInCheckAfterMove) {
                return false; // O movimento é ilegal porque deixa o rei do jogador atual em xeque
            }

            return true; // O movimento é válido e legal
        }

        /**
         * Retorna um array de movimentos pseudo-legais para uma determinada peça em uma posição específica.
         * Movimentos pseudo-legais são baseados no padrão de movimento e regras de captura da peça,
         * mas NÃO consideram se o movimento coloca ou deixa o rei do jogador atual em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} row - A linha atual da peça.
         * @param {number} col - A coluna atual da peça.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {Array<Array<number>>} - Um array de pares [linha, coluna] representando movimentos pseudo-legais.
         */
        function getPossibleMoves(piece, row, col, currentBoard = board) {
            const moves = [];
            const isWhite = isWhitePiece(piece);
            const pieceType = piece.toLowerCase();

            const addMove = (r, c) => {
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = currentBoard[r][c];
                    // Se o quadrado de destino estiver vazio ou contiver uma peça do oponente
                    if (!targetPiece || (isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece))) {
                        moves.push([r, c]);
                    }
                }
            };

            const checkPath = (dr, dc) => {
                for (let i = 1; i < 8; i++) {
                    const r = row + i * dr;
                    const c = col + i * dc;
                    if (r < 0 || r > 7 || c < 0 || c > 7) break;
                    const targetPiece = currentBoard[r][c];
                    if (targetPiece) {
                        if ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece))) {
                            addMove(r, c); // Pode capturar
                        }
                        break; // Caminho bloqueado por qualquer peça
                    }
                    addMove(r, c);
                }
            };

            switch (pieceType) {
                case 'p': // Peão
                    const direction = isWhite ? -1 : 1;
                    const startRow = isWhite ? 6 : 1;

                    // Movimento único para frente
                    if (currentBoard[row + direction] && !currentBoard[row + direction][col]) {
                        addMove(row + direction, col);
                        // Movimento duplo inicial para frente
                        if (row === startRow && currentBoard[row + 2 * direction] && !currentBoard[row + 2 * direction][col]) {
                            addMove(row + 2 * direction, col);
                        }
                    }

                    // Capturas (movimentos diagonais apenas se capturando)
                    // Captura esquerda
                    if (col > 0) {
                        const targetPiece = currentBoard[row + direction]?.[col - 1];
                        if (targetPiece && ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece)))) {
                            addMove(row + direction, col - 1);
                        }
                    }
                    // Captura direita
                    if (col < 7) {
                        const targetPiece = currentBoard[row + direction]?.[col + 1];
                        if (targetPiece && ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece)))) {
                            addMove(row + direction, col + 1);
                        }
                    }
                    break;
                case 'r': // Torre
                    checkPath(1, 0); checkPath(-1, 0); // Vertical
                    checkPath(0, 1); checkPath(0, -1); // Horizontal
                    break;
                case 'n': // Cavalo
                    const knightMoves = [
                        [2, 1], [2, -1], [-2, 1], [-2, -1],
                        [1, 2], [1, -2], [-1, 2], [-1, -2]
                    ];
                    knightMoves.forEach(([dr, dc]) => addMove(row + dr, col + dc));
                    break;
                case 'b': // Bispo
                    checkPath(1, 1); checkPath(1, -1); // Diagonal
                    checkPath(-1, 1); checkPath(-1, -1);
                    break;
                case 'q': // Rainha
                    checkPath(1, 0); checkPath(-1, 0); // Vertical
                    checkPath(0, 1); checkPath(0, -1); // Horizontal
                    checkPath(1, 1); checkPath(1, -1); // Diagonal
                    checkPath(-1, 1); checkPath(-1, -1);
                    break;
                case 'k': // Rei
                    const kingMoves = [
                        [1, 0], [-1, 0], [0, 1], [0, -1],
                        [1, 1], [1, -1], [-1, 1], [-1, -1]
                    ];
                    kingMoves.forEach(([dr, dc]) => addMove(row + dr, col + dc));

                    // Adiciona roque como movimentos pseudo-legais (quadrados de destino do rei)
                    // Roque do lado do rei
                    if (isWhite) {
                        if (!whiteKingMoved && !whiteRookRightMoved &&
                            currentBoard[7][5] === '' && currentBoard[7][6] === '') {
                            moves.push([7, 6]); // Quadrado alvo para roque do lado do rei
                        }
                        // Roque do lado da rainha
                        if (!whiteKingMoved && !whiteRookLeftMoved &&
                            currentBoard[7][1] === '' && currentBoard[7][2] === '' && currentBoard[7][3] === '') {
                            moves.push([7, 2]); // Quadrado alvo para roque do lado da rainha
                        }
                    } else { // Rei Preto
                        if (!blackKingMoved && !blackRookRightMoved &&
                            currentBoard[0][5] === '' && currentBoard[0][6] === '') {
                            moves.push([0, 6]); // Quadrado alvo para roque do lado do rei
                        }
                        if (!blackKingMoved && !blackRookLeftMoved &&
                            currentBoard[0][1] === '' && currentBoard[0][2] === '' && currentBoard[0][3] === '') {
                            moves.push([0, 2]); // Quadrado alvo para roque do lado da rainha
                        }
                    }
                    break;
            }
            return moves;
        }

        /**
         * Retorna um array de movimentos verdadeiramente legais para uma determinada peça em uma posição específica.
         * Movimentos legais são movimentos pseudo-legais que NÃO colocam ou deixam o rei do jogador atual em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} row - A linha atual da peça.
         * @param {number} col - A coluna atual da peça.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {Array<Array<number>>} - Um array de pares [linha, coluna] representando movimentos legais.
         */
        function getLegalMoves(piece, row, col, currentBoard = board) {
            const pseudoLegalMoves = getPossibleMoves(piece, row, col, currentBoard); // Obtém movimentos baseados no padrão da peça
            const legalMoves = [];
            const originalCurrentPlayer = currentPlayer; // Armazena o jogador original

            pseudoLegalMoves.forEach(([toR, toC]) => {
                // Para movimentos de roque, o quadrado alvo é onde o Rei aterrissa.
                // Precisamos verificar as condições de roque novamente aqui, especialmente os quadrados atacados.
                if (piece.toLowerCase() === 'k' && (Math.abs(toC - col) === 2)) {
                    // Este é um movimento pseudo-roque. Determina a coluna original da torre.
                    const rookOriginalCol = (toC > col) ? 7 : 0;
                    // Passa currentBoard para isValidCastling
                    if (isValidCastling(row, col, toR, rookOriginalCol, currentBoard)) {
                        legalMoves.push([toR, toC]);
                    }
                } else {
                    // Para movimentos regulares, usa isValidMove
                    // Define temporariamente o jogador atual para aquele cujos movimentos estamos testando
                    // Isso é crucial para isValidMove verificar corretamente a segurança do rei para este jogador.
                    currentPlayer = isWhitePiece(piece) ? 'white' : 'black';

                    if (isValidMove(piece, row, col, toR, toC, currentBoard)) {
                        legalMoves.push([toR, toC]);
                    }
                }
            });

            currentPlayer = originalCurrentPlayer; // Reverte para o jogador original
            return legalMoves;
        }

        /**
         * Verifica se um movimento de roque é válido.
         * Esta função verifica todas as condições para o roque, incluindo histórico de movimento do rei e da torre,
         * caminho livre e segurança do rei (não em xeque, não passando por quadrados atacados, não aterrissando em quadrado atacado).
         * @param {number} kingStartRow - A linha da posição inicial do Rei.
         * @param {number} kingStartCol - A coluna da posição inicial do Rei.
         * @param {number} kingEndRow - A linha da posição final do Rei (quadrado de roque).
         * @param {number} rookOriginalCol - A coluna original da Torre envolvida no roque.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {boolean} - True se o movimento de roque for válido.
         */
        function isValidCastling(kingStartRow, kingStartCol, kingEndRow, rookOriginalCol, currentBoard = board) {
            const kingPiece = currentBoard[kingStartRow][kingStartCol];
            const rookPiece = currentBoard[kingEndRow][rookOriginalCol]; // A Torre está na mesma linha que o rei

            // 1. Verifica se as peças são Rei e Torre
            if (kingPiece.toLowerCase() !== 'k' || !rookPiece || rookPiece.toLowerCase() !== 'r') return false;

            // 2. Verifica se o Rei e a Torre são da mesma cor e pertencem ao jogador atual
            if (!isCurrentPlayerPiece(kingPiece) || !isCurrentPlayerPiece(rookPiece)) return false;
            if (isWhitePiece(kingPiece) !== isWhitePiece(rookPiece)) return false;

            const isWhite = isWhitePiece(kingPiece);

            // 3. Verifica se o Rei e a Torre se moveram (usa flags globais para o jogo real, não tabuleiro simulado)
            // Nota: Para simulação de minimax, essas flags não são passadas, então esta verificação dependerá do estado global.
            // Uma IA mais robusta passaria essas flags como parte do estado simulado.
            if (isWhite) {
                if (whiteKingMoved) return false;
                if (rookOriginalCol === 0 && whiteRookLeftMoved) return false;
                if (rookOriginalCol === 7 && whiteRookRightMoved) return false;
            } else {
                if (blackKingMoved) return false;
                if (rookOriginalCol === 0 && blackRookLeftMoved) return false;
                if (rookOriginalCol === 7 && blackRookRightMoved) return false;
            }

            // 4. Verifica se o caminho entre o Rei e a Torre está livre
            if (rookOriginalCol === 7) { // Roque do lado do rei
                if (currentBoard[kingStartRow][5] !== '' || currentBoard[kingStartRow][6] !== '') return false;
            } else if (rookOriginalCol === 0) { // Roque do lado da rainha
                if (currentBoard[kingStartRow][1] !== '' || currentBoard[kingStartRow][2] !== '' || currentBoard[kingStartRow][3] !== '') return false;
            } else {
                return false; // Torre não está em uma posição de roque válida
            }

            // 5. Verifica se o Rei está atualmente em xeque
            if (isKingInCheck(isWhite ? 'white' : 'black', currentBoard)) return false;

            // 6. Verifica se o Rei passa por ou aterrissa em um quadrado atacado
            const opponentColor = isWhite ? 'black' : 'white';
            if (rookOriginalCol === 7) { // Roque do lado do rei
                if (isSquareAttacked(kingStartRow, kingStartCol + 1, opponentColor, currentBoard) || // Quadrado pelo qual o Rei passa
                    isSquareAttacked(kingStartRow, kingStartCol + 2, opponentColor, currentBoard)) { // Quadrado onde o Rei aterrissa
                    return false;
                }
            } else if (rookOriginalCol === 0) { // Roque do lado da rainha
                if (isSquareAttacked(kingStartRow, kingStartCol - 1, opponentColor, currentBoard) || // Quadrado pelo qual o Rei passa
                    isSquareAttacked(kingStartRow, kingStartCol - 2, opponentColor, currentBoard)) { // Quadrado onde o Rei aterrissa
                    return false;
                }
            }

            return true;
        }

        /**
         * Encontra a posição do Rei para um determinado jogador.
         * @param {string} playerColor - 'white' ou 'black'.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {Array<number>|null} - [linha, coluna] do Rei, ou null se não encontrado.
         */
        function findKing(playerColor, currentBoard = board) {
            const kingPiece = playerColor === 'white' ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === kingPiece) {
                        return [r, c];
                    }
                }
            }
            return null; // Não deve acontecer em um jogo válido
        }

        /**
         * Verifica se o rei dado está atualmente em xeque.
         * @param {string} kingColor - A cor do rei a ser verificado ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {boolean} - True se o rei estiver em xeque.
         */
        function isKingInCheck(kingColor, currentBoard = board) {
            const kingPos = findKing(kingColor, currentBoard);
            if (!kingPos) return false; // Rei não encontrado (ex: em um estado de tabuleiro simulado onde foi capturado)

            const [kingRow, kingCol] = kingPos;
            const opponentColor = kingColor === 'white' ? 'black' : 'white';

            return isSquareAttacked(kingRow, kingCol, opponentColor, currentBoard);
        }

        /**
         * Verifica se um quadrado específico é atacado por uma peça de uma determinada cor.
         * Esta função é crucial para a segurança do rei e validação do roque.
         * @param {number} row - A linha do quadrado a ser verificado.
         * @param {number} col - A coluna do quadrado a ser verificado.
         * @param {string} attackerColor - A cor das peças que podem estar atacando.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {boolean} - True se o quadrado for atacado por um atacante da cor especificada.
         */
        function isSquareAttacked(row, col, attackerColor, currentBoard = board) {
            const originalCurrentPlayer = currentPlayer; // Armazena o jogador original
            currentPlayer = attackerColor; // Define temporariamente o jogador atual para o atacante para usar getPossibleMoves corretamente

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    // Verifica se a peça pertence ao attackerColor
                    if (piece && ((attackerColor === 'white' && isWhitePiece(piece)) || (attackerColor === 'black' && isBlackPiece(piece)))) {
                        // Obtém os movimentos pseudo-legais que esta peça atacante *poderia* fazer
                        const attackerPseudoLegalMoves = getPossibleMoves(piece, r, c, currentBoard);

                        // Verifica se algum dos movimentos pseudo-legais do atacante visa o quadrado especificado
                        if (attackerPseudoLegalMoves.some(([moveR, moveC]) => moveR === row && moveC === col)) {
                            currentPlayer = originalCurrentPlayer; // Reverte antes de retornar
                            return true; // A peça atacante pode atacar o quadrado
                        }
                    }
                }
            }
            currentPlayer = originalCurrentPlayer; // Reverte se nenhum ataque for encontrado
            return false;
        }

        /**
         * Verifica se o jogador atual está em xeque-mate.
         * Itera por todos os movimentos legais possíveis para o jogador atual.
         * @param {string} playerColor - A cor do jogador a ser verificado ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {boolean} - True se o jogador estiver em xeque-mate.
         */
        function isCheckmate(playerColor, currentBoard = board) {
            if (!isKingInCheck(playerColor, currentBoard)) {
                return false; // Não está em xeque, então não pode ser xeque-mate
            }

            // Se estiver em xeque, verifica se há algum movimento legal para sair do xeque
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        // Obtém todos os movimentos legais para esta peça (que já considera a segurança do rei)
                        const legalMoves = getLegalMoves(piece, r, c, currentBoard);
                        if (legalMoves.length > 0) {
                            return false; // Encontrou pelo menos um movimento legal, então não é xeque-mate
                        }
                    }
                }
            }
            return true; // Nenhum movimento legal encontrado para nenhuma peça, e o rei está em xeque, então é xeque-mate
        }

        /**
         * Verifica se o jogador atual está em afogamento (empate por falta de movimentos legais).
         * @param {string} playerColor - A cor do jogador a ser verificado ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser verificado.
         * @returns {boolean} - True se o jogador estiver em afogamento.
         */
        function isStalemate(playerColor, currentBoard = board) {
            if (isKingInCheck(playerColor, currentBoard)) {
                return false; // Se estiver em xeque, não é afogamento (é xeque-mate se não houver movimentos legais)
            }

            // Verifica se o jogador atual tem algum movimento legal
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        const legalMoves = getLegalMoves(piece, r, c, currentBoard);
                        if (legalMoves.length > 0) {
                            return false; // Encontrou pelo menos um movimento legal, então não é afogamento
                        }
                    }
                }
            }
            return true; // Nenhum movimento legal encontrado para nenhuma peça, e o rei NÃO está em xeque, então é afogamento
        }

        /**
         * Avalia o estado atual do tabuleiro da perspectiva do jogador maximizador (IA, que é o preto).
         * Uma pontuação positiva favorece o preto, uma pontuação negativa favorece o branco.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser avaliado.
         * @returns {number} - A pontuação do tabuleiro.
         */
        function evaluateBoard(currentBoard) {
            let score = 0;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece) {
                        // Adiciona o valor base da peça (positivo para preto, negativo para branco)
                        score += PIECE_VALUES[piece] || 0;

                        // Adiciona pontuação posicional
                        const pieceType = piece.toLowerCase();
                        const isWhite = isWhitePiece(piece);
                        let positionalValue = 0;

                        // As tabelas de posição são da perspectiva do branco.
                        // Para peças pretas, precisamos inverter o índice da linha para obter o valor posicional correto.
                        const tableRow = isWhite ? r : 7 - r;
                        const tableCol = c;

                        switch (pieceType) {
                            case 'p':
                                positionalValue = PAWN_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'n':
                                positionalValue = KNIGHT_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'b':
                                positionalValue = BISHOP_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'r':
                                positionalValue = ROOK_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'q':
                                positionalValue = QUEEN_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'k':
                                // Determina se é o final do jogo para usar a tabela de rei apropriada
                                // Heurística simples: se o total de peças for baixo, é o final do jogo
                                let totalNonKingPieces = 0;
                                for (let i = 0; i < 8; i++) {
                                    for (let j = 0; j < 8; j++) {
                                        const p = currentBoard[i][j];
                                        if (p && p.toLowerCase() !== 'k') {
                                            totalNonKingPieces++;
                                        }
                                    }
                                }
                                if (totalNonKingPieces < 8) { // Limiar arbitrário para o final do jogo
                                    positionalValue = KING_POSITION_TABLE_END_GAME[tableRow][tableCol];
                                } else {
                                    positionalValue = KING_POSITION_TABLE_MIDDLE_GAME[tableRow][tableCol];
                                }
                                break;
                        }
                        // Se for uma peça branca, seu valor posicional é subtraído da pontuação do preto.
                        // Se for uma peça preta, seu valor posicional é adicionado à pontuação do preto.
                        score += (isWhite ? -positionalValue : positionalValue);
                    }
                }
            }

            // Adiciona bônus para xeque-mate/afogamento
            if (isCheckmate('white', currentBoard)) {
                score += 100000000; // Grande bônus para o preto dando xeque-mate no branco
            } else if (isCheckmate('black', currentBoard)) {
                score -= 100000000; // Grande penalidade para o preto sendo xeque-mate
            } else if (isStalemate('white', currentBoard) || isStalemate('black', currentBoard)) {
                score += 0; // Afogamento é um empate, sem mudança na pontuação
            }

            // Adiciona um bônus por colocar o oponente em xeque
            if (isKingInCheck('white', currentBoard)) { // Se o rei branco estiver em xeque
                score += 5000; // Bônus significativo para a IA (preto)
            }
            // Adiciona uma penalidade para o preto estar em xeque
            if (isKingInCheck('black', currentBoard)) { // Se o rei preto estiver em xeque
                score -= 5000; // Penalidade significativa para a IA (preto)
            }

            return score;
        }

        /**
         * Decide a melhor peça para a promoção de peão da IA usando avaliação.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro antes da promoção.
         * @param {number} row - A linha onde o peão está promovendo.
         * @param {number} col - A coluna onde o peão está promovendo.
         * @param {boolean} isWhitePawn - True se o peão sendo promovido for branco.
         * @returns {string} O caractere da melhor peça para promover.
         */
        function decidePromotionPieceForAI(currentBoard, row, col, isWhitePawn) {
            const possiblePromotions = ['Q', 'R', 'B', 'N'];
            let bestPromotedPiece = isWhitePawn ? 'Q' : 'q'; // Padrão para Rainha
            let bestEvaluation = isWhitePawn ? Infinity : -Infinity; // Branco minimiza, Preto maximiza

            for (const pieceType of possiblePromotions) {
                const promotedPieceChar = isWhitePawn ? pieceType : pieceType.toLowerCase();
                const tempBoard = JSON.parse(JSON.stringify(currentBoard)); // Cria uma cópia

                // Promove temporariamente o peão no tabuleiro copiado
                tempBoard[row][col] = promotedPieceChar;

                const evaluation = evaluateBoard(tempBoard);

                if (isWhitePawn) { // IA Branca (jogador minimizador, mas este ramo não será usado, pois nossa IA é preta)
                    if (evaluation < bestEvaluation) {
                        bestEvaluation = evaluation;
                        bestPromotedPiece = promotedPieceChar;
                    }
                } else { // IA Preta (jogador maximizador)
                    if (evaluation > bestEvaluation) {
                        bestEvaluation = evaluation;
                        bestPromotedPiece = promotedPieceChar;
                    }
                }
            }
            return bestPromotedPiece;
        }

        /**
         * Realiza uma busca de quiescência para avaliar posições ruidosas.
         * @param {Array<Array<string>>} currentBoard - O estado atual do tabuleiro.
         * @param {number} depth - A profundidade atual da busca de quiescência.
         * @param {boolean} isMaximizingPlayer - True se for o turno do jogador maximizador (IA, preto).
         * @param {number} alpha - A melhor pontuação que o jogador maximizador pode garantir até agora.
         * @param {number} beta - A melhor pontuação que o jogador minimizador pode garantir até agora.
         * @param {object} castlingFlags - Objeto com as flags de roque atuais.
         * @returns {number} - A melhor pontuação encontrada para a posição ruidosa atual.
         */
        function quiescenceSearch(currentBoard, depth, isMaximizingPlayer, alpha, beta, castlingFlags) {
            // Avalia o estado "quieto" atual (nenhum movimento tático imediato considerado ainda)
            let evaluation = evaluateBoard(currentBoard);

            if (isMaximizingPlayer) {
                alpha = Math.max(alpha, evaluation);
            } else {
                beta = Math.min(beta, evaluation);
            }

            if (alpha >= beta) {
                return evaluation; // Corte Alpha-beta
            }

            // Considera apenas movimentos de captura na busca de quiescência
            const movesToConsider = [];
            const playerColor = isMaximizingPlayer ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        const pseudoLegalMoves = getPossibleMoves(piece, r, c, currentBoard);
                        pseudoLegalMoves.forEach(([toR, toC]) => {
                            const targetPiece = currentBoard[toR][toC];
                            // Adiciona apenas se for uma captura
                            if (targetPiece && ((isWhitePiece(piece) && isBlackPiece(targetPiece)) || (isBlackPiece(piece) && isWhitePiece(targetPiece)))) {
                                // Verifica se o movimento é legal (não coloca o próprio rei em xeque)
                                const originalCurrentPlayer = currentPlayer;
                                currentPlayer = playerColor; // Define temporariamente para o jogador atual para isValidMove
                                if (isValidMove(piece, r, c, toR, toC, currentBoard)) {
                                    movesToConsider.push({
                                        from: [r, c],
                                        to: [toR, toC],
                                        piece: piece,
                                        capturedPiece: targetPiece,
                                        capturedPieceValue: Math.abs(PIECE_VALUES[targetPiece])
                                    });
                                }
                                currentPlayer = originalCurrentPlayer; // Reverte
                            }
                        });
                    }
                }
            }

            // Ordena as capturas por valor (captura de maior valor primeiro) para melhor poda
            movesToConsider.sort((a, b) => b.capturedPieceValue - a.capturedPieceValue);

            if (isMaximizingPlayer) {
                let maxEval = evaluation; // Começa com a avaliação estática da posição atual
                for (const move of movesToConsider) {
                    const { from: [fromR, fromC], to: [toR, toC], piece } = move;

                    const newBoard = JSON.parse(JSON.stringify(currentBoard));
                    const originalPiece = newBoard[fromR][fromC];
                    const capturedPiece = newBoard[toR][toC];

                    newBoard[toR][toC] = originalPiece;
                    newBoard[fromR][fromC] = '';

                    // Promoção de Peão no tabuleiro simulado (IA sempre promove para Rainha)
                    let promotedPiece = originalPiece;
                    if (originalPiece.toLowerCase() === 'p') {
                        if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                            promotedPiece = isWhitePiece(originalPiece) ? 'Q' : 'q'; // Ainda padrão para Rainha para simplificar na busca de quiescência
                            newBoard[toR][toC] = promotedPiece; // Atualiza a peça no novo tabuleiro
                        }
                    }

                    const newCastlingFlags = { ...castlingFlags }; // Passa as flags atualizadas
                    if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                    if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 0) newCastlingFlags.whiteRookLeftMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 7) newCastlingFlags.whiteRookRightMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 0) newCastlingFlags.blackRookLeftMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 7) newCastlingFlags.blackRookRightMoved = true;

                    const evalResult = quiescenceSearch(newBoard, depth - 1, false, alpha, beta, newCastlingFlags);
                    maxEval = Math.max(maxEval, evalResult);
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) {
                        break;
                    }
                }
                return maxEval;
            } else { // Jogador minimizador
                let minEval = evaluation; // Começa com a avaliação estática
                for (const move of movesToConsider) {
                    const { from: [fromR, fromC], to: [toR, toC], piece } = move;

                    const newBoard = JSON.parse(JSON.stringify(currentBoard));
                    const originalPiece = newBoard[fromR][fromC];
                    const capturedPiece = newBoard[toR][toC];

                    newBoard[toR][toC] = originalPiece;
                    newBoard[fromR][fromC] = '';

                    // Promoção de Peão no tabuleiro simulado (IA sempre promove para Rainha)
                    let promotedPiece = originalPiece;
                    if (originalPiece.toLowerCase() === 'p') {
                        if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                            promotedPiece = isWhitePiece(originalPiece) ? 'Q' : 'q'; // Ainda padrão para Rainha para simplificar na busca de quiescência
                            newBoard[toR][toC] = promotedPiece; // Atualiza a peça no novo tabuleiro
                        }
                    }

                    const newCastlingFlags = { ...castlingFlags }; // Passa as flags atualizadas
                    if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                    if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 0) newCastlingFlags.whiteRookLeftMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 7) newCastlingFlags.whiteRookRightMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 0) newCastlingFlags.blackRookLeftMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 7) newCastlingFlags.blackRookRightMoved = true;

                    const evalResult = quiescenceSearch(newBoard, depth - 1, true, alpha, beta, newCastlingFlags);
                    minEval = Math.min(minEval, evalResult);
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) {
                        break;
                    }
                }
                return minEval;
            }
        }


        /**
         * Algoritmo Minimax com Poda Alpha-Beta para encontrar o melhor movimento.
         * @param {Array<Array<string>>} currentBoard - O estado atual do tabuleiro.
         * @param {number} depth - A profundidade atual da busca.
         * @param {boolean} isMaximizingPlayer - True se for o turno do jogador maximizador (IA, preto).
         * @param {number} alpha - A melhor pontuação que o jogador maximizador pode garantir até agora.
         * @param {number} beta - A melhor pontuação que o jogador minimizador pode garantir até agora.
         * @param {object} castlingFlags - Objeto com as flags de roque atuais (whiteKingMoved, etc.).
         * @returns {number} - A melhor pontuação encontrada para o estado atual do tabuleiro.
         */
        function minimax(currentBoard, depth, isMaximizingPlayer, alpha, beta, castlingFlags) {
            // Calcula o hash para o estado atual do tabuleiro
            const boardHash = calculateBoardHash(currentBoard, isMaximizingPlayer ? 'black' : 'white', castlingFlags);

            // Verifica a tabela de transposição
            if (transpositionTable.has(boardHash)) {
                const entry = transpositionTable.get(boardHash);
                if (entry.depth >= depth) { // Se a avaliação armazenada for de uma busca mais profunda ou igual
                    return entry.evaluation;
                }
            }

            // Caso base: se a profundidade for 0, chama a busca de quiescência
            if (depth === 0) {
                const evaluation = quiescenceSearch(currentBoard, 3, isMaximizingPlayer, alpha, beta, castlingFlags); // Profundidade da busca de quiescência 3
                transpositionTable.set(boardHash, { evaluation, depth });
                return evaluation;
            }

            // Verifica estados de fim de jogo
            if (isCheckmate('white', currentBoard) || isCheckmate('black', currentBoard) || isStalemate('white', currentBoard) || isStalemate('black', currentBoard)) {
                const evaluation = evaluateBoard(currentBoard); // Avalia o estado final do jogo
                transpositionTable.set(boardHash, { evaluation, depth });
                return evaluation;
            }


            if (isMaximizingPlayer) { // Turno da IA (preto) - maximiza a pontuação
                let maxEval = -Infinity;
                const playerColor = 'black';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && isBlackPiece(piece)) {
                            const moves = getLegalMoves(piece, r, c, currentBoard);
                            // Ordena os movimentos para eficiência da poda Alpha-Beta dentro do minimax
                            moves.sort((a, b) => {
                                const targetPieceA = currentBoard[a[0]][a[1]]; // Peça no destino para o movimento A
                                const targetPieceB = currentBoard[b[0]][b[1]]; // Peça no destino para o movimento B
                                const valueA = targetPieceA ? Math.abs(PIECE_VALUES[targetPieceA]) : 0;
                                const valueB = targetPieceB ? Math.abs(PIECE_VALUES[targetPieceB]) : 0;
                                return valueB - valueA; // Prioriza capturas de peças de maior valor
                            });

                            for (const [toR, toC] of moves) {
                                // Simula o movimento
                                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                                const originalPiece = newBoard[r][c];
                                const capturedPiece = newBoard[toR][toC];

                                newBoard[toR][toC] = originalPiece;
                                newBoard[r][c] = '';

                                // Promoção de Peão no tabuleiro simulado
                                let simulatedMovedPiece = originalPiece;
                                if (originalPiece.toLowerCase() === 'p') {
                                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                                    }
                                }


                                // Simula a atualização das flags de roque para a chamada recursiva
                                const newCastlingFlags = { ...castlingFlags };
                                if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                                if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 0) newCastlingFlags.whiteRookLeftMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 7) newCastlingFlags.whiteRookRightMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 0) newCastlingFlags.blackRookLeftMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 7) newCastlingFlags.blackRookRightMoved = true;

                                // Lida com o movimento simulado da torre no roque
                                if (piece.toLowerCase() === 'k' && Math.abs(toC - c) === 2) {
                                    let rookOriginalCol;
                                    let rookFinalCol;
                                    if (toC > c) { // Roque do lado do rei
                                        rookOriginalCol = 7;
                                        rookFinalCol = c + 1;
                                    } else { // Roque do lado da rainha
                                        rookOriginalCol = 0;
                                        rookFinalCol = c - 1;
                                    }
                                    const rookPiece = newBoard[r][rookOriginalCol];
                                    newBoard[r][rookFinalCol] = rookPiece;
                                    newBoard[r][rookOriginalCol] = '';
                                }

                                const evaluation = minimax(newBoard, depth - 1, false, alpha, beta, newCastlingFlags);
                                maxEval = Math.max(maxEval, evaluation);
                                alpha = Math.max(alpha, maxEval);

                                if (beta <= alpha) { // Poda Alpha-Beta
                                    break;
                                }
                            }
                        }
                    }
                }
                transpositionTable.set(boardHash, { evaluation: maxEval, depth }); // Armazena a avaliação
                return maxEval;
            } else { // Turno do oponente (branco) - minimiza a pontuação
                let minEval = Infinity;
                const playerColor = 'white';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && isWhitePiece(piece)) {
                            const moves = getLegalMoves(piece, r, c, currentBoard);
                            // Ordena os movimentos para eficiência da poda Alpha-Beta dentro do minimax
                            moves.sort((a, b) => {
                                const targetPieceA = currentBoard[a[0]][a[1]]; // Peça no destino para o movimento A
                                const targetPieceB = currentBoard[b[0]][b[1]]; // Peça no destino para o movimento B
                                const valueA = targetPieceA ? Math.abs(PIECE_VALUES[targetPieceA]) : 0;
                                const valueB = targetPieceB ? Math.abs(PIECE_VALUES[targetPieceB]) : 0;
                                return valueB - valueA; // Prioriza capturas de peças de maior valor
                            });

                            for (const [toR, toC] of moves) {
                                // Simula o movimento
                                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                                const originalPiece = newBoard[r][c];
                                const capturedPiece = newBoard[toR][toC];

                                newBoard[toR][toC] = originalPiece;
                                newBoard[r][c] = '';

                                // Promoção de Peão no tabuleiro simulado
                                let simulatedMovedPiece = originalPiece;
                                if (originalPiece.toLowerCase() === 'p') {
                                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                                    }
                                }

                                // Simula a atualização das flags de roque para a chamada recursiva
                                const newCastlingFlags = { ...castlingFlags };
                                if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                                if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 0) newCastlingFlags.whiteRookLeftMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 7) newCastlingFlags.whiteRookRightMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 0) newCastlingFlags.blackRookLeftMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 7) newCastlingFlags.blackRookRightMoved = true;

                                // Lida com o movimento simulado da torre no roque
                                if (piece.toLowerCase() === 'k' && Math.abs(toC - c) === 2) {
                                    let rookOriginalCol;
                                    let rookFinalCol;
                                    if (toC > c) { // Roque do lado do rei
                                        rookOriginalCol = 7;
                                        rookFinalCol = c + 1;
                                    } else { // Roque do lado da rainha
                                        rookOriginalCol = 0;
                                        rookFinalCol = c - 1;
                                    }
                                    const rookPiece = newBoard[r][rookOriginalCol];
                                    newBoard[r][rookFinalCol] = rookPiece;
                                    newBoard[r][rookOriginalCol] = '';
                                }

                                const evaluation = minimax(newBoard, depth - 1, true, alpha, beta, newCastlingFlags);
                                minEval = Math.min(minEval, evaluation);
                                beta = Math.min(beta, minEval);

                                if (beta <= alpha) { // Poda Alpha-Beta
                                    break;
                                }
                            }
                        }
                    }
                }
                transpositionTable.set(boardHash, { evaluation: minEval, depth }); // Armazena a avaliação
                return minEval;
            }
        }

        /**
         * Faz um movimento para o computador (IA).
         */
        function makeComputerMove() {
            if (gameOver || currentPlayer !== 'black') {
                isThinking = false;
                updateHistoryButtons();
                updateStatus(); // Garante que o status seja atualizado se a IA não deveria se mover
                return;
            }

            let bestMove = null;
            let maxEval = -Infinity;
            const searchDepth = aiSearchDepth; // Usa a profundidade de busca da IA selecionada

            // Itera por todos os movimentos possíveis para a IA (peças pretas)
            const allPossibleMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && isBlackPiece(piece)) {
                        const moves = getLegalMoves(piece, r, c, board);
                        moves.forEach(([toR, toC]) => {
                            const pieceAtTargetForMove = board[toR][toC]; // Obtém a peça do tabuleiro real antes de simular
                            allPossibleMoves.push({
                                from: [r, c],
                                to: [toR, toC],
                                piece: piece,
                                capturedPiece: pieceAtTargetForMove, // Armazena o caractere da peça capturada real
                                capturedPieceValue: pieceAtTargetForMove ? Math.abs(PIECE_VALUES[pieceAtTargetForMove]) : 0
                            });
                        });
                    }
                }
            }

            // Ordena os movimentos para eficiência da poda Alpha-Beta
            allPossibleMoves.sort((a, b) => {
                // Prioriza capturas de peças de maior valor
                if (a.capturedPieceValue !== b.capturedPieceValue) {
                    return b.capturedPieceValue - a.capturedPieceValue; // Ordem decrescente para capturas
                }

                // Se o valor capturado for o mesmo, prioriza movimentos que dão xeque
                // Simula o tabuleiro para o movimento A
                const boardAfterA = JSON.parse(JSON.stringify(board));
                boardAfterA[a.to[0]][a.to[1]] = boardAfterA[a.from[0]][a.from[1]];
                boardAfterA[a.from[0]][a.from[1]] = '';
                // Simula o movimento da torre no roque para A, se aplicável
                if (a.piece.toLowerCase() === 'k' && Math.abs(a.to[1] - a.from[1]) === 2) {
                    let rookOriginalColA = (a.to[1] > a.from[1]) ? 7 : 0;
                    let rookFinalColA = (a.to[1] > a.from[1]) ? a.from[1] + 1 : a.from[1] - 1;
                    const rookPieceA = boardAfterA[a.from[0]][rookOriginalColA];
                    boardAfterA[a.from[0]][rookFinalColA] = rookPieceA;
                    boardAfterA[a.from[0]][rookOriginalColA] = '';
                }
                // Promoção de Peão no tabuleiro simulado para A (IA sempre promove para Rainha)
                if (a.piece.toLowerCase() === 'p') {
                    if ((isWhitePiece(a.piece) && a.to[0] === 0) || (isBlackPiece(a.piece) && a.to[0] === 7)) {
                        // Para ordenação, assume temporariamente a promoção para rainha para uma verificação rápida
                        boardAfterA[a.to[0]][a.to[1]] = isWhitePiece(a.piece) ? 'Q' : 'q';
                    }
                }

                // Define temporariamente o jogador atual para preto para isKingInCheck
                const originalCurrentPlayer = currentPlayer;
                currentPlayer = 'black';
                const aGivesCheck = isKingInCheck('white', boardAfterA); // Verifica se o rei branco está em xeque
                currentPlayer = originalCurrentPlayer; // Reverte

                // Simula o tabuleiro para o movimento B
                const boardAfterB = JSON.parse(JSON.stringify(board));
                boardAfterB[b.to[0]][b.to[1]] = boardAfterB[b.from[0]][b.from[1]];
                boardAfterB[b.from[0]][b.from[1]] = '';
                // Simula o movimento da torre no roque para B, se aplicável
                if (b.piece.toLowerCase() === 'k' && Math.abs(b.to[1] - b.from[1]) === 2) {
                    let rookOriginalColB = (b.to[1] > b.from[1]) ? 7 : 0;
                    let rookFinalColB = (b.to[1] > b.from[1]) ? b.from[1] + 1 : b.from[1] - 1;
                    const rookPieceB = boardAfterB[b.from[0]][rookOriginalColB];
                    boardAfterB[b.from[0]][rookFinalColB] = rookPieceB;
                    boardAfterB[b.from[0]][rookOriginalColB] = '';
                }
                // Promoção de Peão no tabuleiro simulado para B (IA sempre promove para Rainha)
                if (b.piece.toLowerCase() === 'p') {
                    if ((isWhitePiece(b.piece) && b.to[0] === 0) || (isBlackPiece(b.piece) && b.to[0] === 7)) {
                        // Para ordenação, assume temporariamente a promoção para rainha para uma verificação rápida
                        boardAfterB[b.to[0]][b.to[1]] = isWhitePiece(b.piece) ? 'Q' : 'q';
                    }
                }

                // Define temporariamente o jogador atual para preto para isKingInCheck
                currentPlayer = 'black';
                const bGivesCheck = isKingInCheck('white', boardAfterB); // Verifica se o rei branco está em xeque
                currentPlayer = originalCurrentPlayer; // Reverte

                if (aGivesCheck && !bGivesCheck) return -1; // A é melhor se der xeque e B não
                if (!aGivesCheck && bGivesCheck) return 1;  // B é melhor se der xeque e A não

                // Caso contrário, mantém a ordem original (aleatoriedade)
                return 0;
            });


            console.log("IA considerando movimentos:"); // Log de depuração
            for (const move of allPossibleMoves) {
                const { from: [fromR, fromC], to: [toR, toC], piece, capturedPiece, capturedPieceValue } = move;

                // Simula o movimento em um tabuleiro temporário
                const newBoard = JSON.parse(JSON.stringify(board));
                const originalPiece = newBoard[fromR][fromC];
                const simulatedCapturedPiece = newBoard[toR][toC]; // Peça que seria capturada na simulação

                newBoard[toR][toC] = originalPiece;
                newBoard[fromR][fromC] = '';

                // Promoção de Peão no tabuleiro simulado para a chamada minimax
                let simulatedMovedPiece = originalPiece;
                if (originalPiece.toLowerCase() === 'p') {
                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                    }
                }


                // Simula a atualização das flags de roque para a chamada minimax
                const simulatedCastlingFlags = {
                    whiteKingMoved: whiteKingMoved,
                    blackKingMoved: blackKingMoved,
                    whiteRookLeftMoved: whiteRookLeftMoved,
                    whiteRookRightMoved: whiteRookRightMoved,
                    blackRookLeftMoved: blackRookLeftMoved,
                    blackRookRightMoved: blackRookRightMoved
                };
                if (originalPiece === 'K') simulatedCastlingFlags.whiteKingMoved = true;
                if (originalPiece === 'k') simulatedCastlingFlags.blackKingMoved = true;
                if (originalPiece === 'R' && fromR === 7 && fromC === 0) simulatedCastlingFlags.whiteRookLeftMoved = true;
                if (originalPiece === 'R' && fromR === 7 && fromC === 7) simulatedCastlingFlags.whiteRookRightMoved = true;
                if (originalPiece === 'r' && fromR === 0 && fromC === 0) simulatedCastlingFlags.blackRookLeftMoved = true;
                if (originalPiece === 'r' && fromR === 0 && fromC === 7) simulatedCastlingFlags.blackRookRightMoved = true;


                // Se for um movimento de roque, também move a torre no tabuleiro simulado
                if (piece.toLowerCase() === 'k' && Math.abs(toC - fromC) === 2) {
                    let rookOriginalCol;
                    let rookFinalCol;
                    if (toC > fromC) { // Roque do lado do rei
                        rookOriginalCol = 7;
                        rookFinalCol = fromC + 1;
                    } else { // Roque do lado da rainha
                        rookOriginalCol = 0;
                        rookFinalCol = fromC - 1;
                    }
                    const rookPiece = newBoard[fromR][rookOriginalCol];
                    newBoard[fromR][rookFinalCol] = rookPiece;
                    newBoard[fromR][rookOriginalCol] = '';
                }

                // Chama minimax com alpha e beta e flags de roque atuais
                const evaluation = minimax(newBoard, searchDepth - 1, false, -Infinity, Infinity, simulatedCastlingFlags);

                let moveDescription = `  Movimento: ${String.fromCharCode(97 + fromC)}${8 - fromR} -> ${String.fromCharCode(97 + toC)}${8 - toR} (Peça: ${piece})`;
                if (capturedPiece) {
                    moveDescription += `, CAPTURA: ${capturedPiece} (Valor: ${capturedPieceValue})`;
                } else {
                    moveDescription += `, Sem Captura`;
                }
                moveDescription += `, Avaliação: ${evaluation}`;
                console.log(moveDescription);

                if (evaluation > maxEval) {
                    maxEval = evaluation;
                    bestMove = move;
                } else if (evaluation === maxEval) {
                    // Se as avaliações forem iguais, prefere movimentos que capturam peças de maior valor
                    // Esta lógica agora é tratada pela ordenação inicial.
                    // Mantém um desempate aleatório para movimentos verdadeiramente idênticos
                    if (Math.random() < 0.5) {
                        bestMove = move;
                    }
                }
            }

            if (bestMove) {
                // Executa o melhor movimento encontrado
                const { from: [fromR, fromC], to: [toR, toC], piece } = bestMove;
                console.log(`Melhor movimento escolhido: ${String.fromCharCode(97 + fromC)}${8 - fromR} -> ${String.fromCharCode(97 + toC)}${8 - toR}, Avaliação Máxima: ${maxEval}`); // Log de depuração

                // Determina a peça final para promoção se for uma promoção de peão
                let finalPromotedPiece = null;
                if (piece.toLowerCase() === 'p' && ((isWhitePiece(piece) && toR === 0) || (isBlackPiece(piece) && toR === 7))) {
                    finalPromotedPiece = decidePromotionPieceForAI(board, toR, toC, isWhitePiece(piece));
                }

                // Lida com o roque como um caso especial para a atualização real do tabuleiro
                if (piece.toLowerCase() === 'k' && Math.abs(toC - fromC) === 2) {
                    let rookOriginalCol;
                    if (toC > fromC) { // Roque do lado do rei
                        rookOriginalCol = 7;
                    } else { // Roque do lado da rainha
                        rookOriginalCol = 0;
                    }
                    makeCastlingMove(fromR, fromC, toR, rookOriginalCol);
                } else {
                    makeMove(fromR, fromC, toR, toC, finalPromotedPiece);
                }

                deselectPiece(); // Garante que nenhuma peça esteja selecionada após o movimento da IA
                switchPlayer(); // Troca para o próximo jogador (humano)
                saveCurrentState(); // Salva o movimento da IA no histórico
            } else {
                // Se nenhum melhor movimento for encontrado (ex: afogamento ou xeque-mate detectado pela IA)
                console.warn("A IA não conseguiu encontrar um movimento. Isso pode indicar afogamento ou xeque-mate.");
                // O estado do jogo já deve ser atualizado por switchPlayer se for xeque-mate/afogamento
            }
            isThinking = false;
            updateHistoryButtons();
            updateStatus();
        }

        // Listeners de eventos para os botões
        resetButton.addEventListener('click', () => initializeNewGame(gameMode)); // Reset irá reinicializar no modo atual
        undoButton.addEventListener('click', undoMove);
        redoButton.addEventListener('click', redoMove);
        backToMenuButton.addEventListener('click', showMainMenu); // Ainda apenas mostra o menu principal
        playVsComputerBtn.addEventListener('click', () => startGameMode('computer')); // Chama a nova função startGameMode
        playVsPlayerBtn.addEventListener('click', () => startGameMode('player')); // Chama a nova função startGameMode

        // Inicializa o jogo sempre mostrando o menu principal primeiro
        document.addEventListener('DOMContentLoaded', () => {
            initializeZobristTable(); // Inicializa a tabela Zobrist uma vez no carregamento
            showMainMenu(); // Sempre inicia no menu principal
        });

        // Adiciona listener de evento para redimensionamento da janela para ajustar o tamanho do quadrado do tabuleiro
        window.addEventListener('resize', adjustChessboardSquareSize);
    </script>
</body>
</html>
