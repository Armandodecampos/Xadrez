<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <!-- Meta tag da viewport corrigida para bloquear o zoom -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jogo de Xadrez</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclui a biblioteca Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        /* Garante que o HTML e o BODY ocupem 100% da viewport para que as unidades vh/vw/vmin funcionem corretamente */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #e2e8f0;
            overflow: hidden; /* Impede barras de rolagem se o conteúdo exceder */
            background-color: #1a202c;
        }

        /* Loading Screen Styles */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a202c; /* Cor de fundo escura */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999; /* Garante que esteja acima de tudo */
            color: #e2e8f0;
            font-size: 4vmin; /* Alterado para vmin */
            font-weight: bold;
            transition: opacity 0.5s ease-out; /* Transição suave ao desaparecer */
        }

        #loadingScreen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .spinner {
            border: 1vmin solid rgba(255, 255, 255, 0.3); /* Alterado para vmin */
            border-top: 1vmin solid #48bb78; /* Alterado para vmin */
            border-radius: 50%;
            width: 7.5vmin; /* Alterado para vmin */
            height: 7.5vmin; /* Alterado para vmin */
            animation: spin 1s linear infinite;
            margin-bottom: 2vmin; /* Alterado para vmin */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Estilo para o fundo da tela inicial */
        #mainMenuBackground {
            background-color: #1a202c; /* Cor de fallback caso a imagem não carregue */
            background-size: cover; /* Cobre todo o elemento */
            background-position: center; /* Centraliza a imagem */
            background-repeat: no-repeat; /* Não repete a imagem */
            background-attachment: fixed; /* Mantém o fundo fixo ao rolar (se houver rolagem) */
            z-index: 0; /* Garante que esteja atrás do conteúdo */
        }

        /* Novo contêiner para o layout principal do jogo (tabuleiro + controles) */
        #gameLayout {
            display: flex;
            flex-direction: column; /* Padrão para coluna em telas pequenas */
            align-items: center;
            justify-content: center;
            gap: 8vmin; /* Espaçamento entre os elementos */
            padding: 4vmin;
            width: 100%;
            height: 100%; /* Garante que ocupe a altura total do body */
            max-width: 1200px; /* Limite de largura para o layout */
            margin: auto; /* Centraliza horizontalmente */
            z-index: 1;
        }

        @media (min-width: 1024px) { /* Em telas maiores (lg) */
            #gameLayout {
                flex-direction: row; /* Muda para linha */
                align-items: flex-start; /* Alinha os itens ao topo na linha */
                justify-content: center;
            }
        }

        /* Contêiner dos controles do jogo (status + botões) */
        #gameControls {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Empurra status para cima e botões para baixo */
            width: 100%; /* Ocupa largura total em telas pequenas */
        }

        @media (min-width: 1024px) { /* Em telas maiores (lg) */
            #gameControls {
                width: 25%; /* Ocupa 1/4 da largura */
                height: auto; /* Altura automática */
                /* min-height: 600px; Removido para maior flexibilidade */
            }
        }

        .game-container {
            display: flex;
            flex-direction: column; /* Mantém para o modal de promoção */
            align-items: center;
            justify-content: center; /* Centraliza o tabuleiro dentro dele */
            width: 100%;
            aspect-ratio: 1/1; /* Garante que o contêiner seja um quadrado */
            position: relative; /* Necessário para posicionamento absoluto do modal de promoção */
            box-sizing: border-box;
            overflow: hidden;
            flex-grow: 1; /* Permite que o tabuleiro cresça para preencher o espaço disponível */
            flex-shrink: 1;
            flex-basis: 0;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr); /* Colunas responsivas */
            grid-template-rows: repeat(8, 1fr); /* Linhas responsivas */
            border: 0.5vmin solid #4a5568; /* Alterado para vmin */
            overflow: hidden; /* Garante que os cantos arredondados se apliquem às casas */
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
            width:70%;
            aspect-ratio: 1 / 1; /* CRUCIAL: Garante que o tabuleiro seja um quadrado */
        }

        /* Removidas as animações de rotação do tabuleiro */

        .square {
            width: 100%; /* Casas preenchem suas células de grade */
            aspect-ratio: 1 / 1; /* Garante que cada casa seja quadrada */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: inherit; /* Herda o tamanho da fonte da peça */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .light {
            background-color: #f0d9b5; /* Cor da casa clara */
        }

        .dark {
            background-color: #b58863; /* Cor da casa escura */
        }

        .selected {
            background-color: #6ee7b7 !important; /* Verde-azulado para peça selecionada */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
        }

        .possible-move {
            background-color: #93c5fd !important; /* Azulado para movimentos possíveis */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
        }

        .piece {
            cursor: grab;
            /* Tamanho responsivo da peça, agora sem limite mínimo/máximo explícito além do vmin */
            font-size: 5vmin; /* Alterado de 30px para 8vmin */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            /* A transição para o movimento será definida dinamicamente no JS */
        }

        /* Removidas as regras CSS de rotação de peça, agora controladas por JS */

        .piece:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .white-piece {
            color: #f7fafc; /* Cor da peça branca */
        }

        .black-piece {
            color: #2d3748; /* Cor da peça preta */
        }

        .status-message {
            font-size: 4vmin; /* Alterado para vmin */
            font-weight: bold;
            text-align: center;
            color: #a0aec0; /* Cinza mais claro para status */
            flex-shrink: 0; /* Impede que a mensagem de status encolha */
            margin-bottom: 2vmin; /* Espaçamento abaixo da mensagem de status */
        }

        .control-buttons {
            display: flex;
            gap: 1.5vmin; /* Espaçamento responsivo entre os botões */
            flex-wrap: wrap; /* Permite que os botões quebrem em telas menores */
            justify-content: center;
            flex-shrink: 0; /* Impede que os botões encolham */
            margin-top: 2vmin; /* Margem responsiva */
        }

        .game-button {
            background-color: #4299e1; /* Botão azul */
            color: white;
            padding: 1.5vmin 3vmin; /* Alterado para vmin */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
            border-radius: 0.5rem; /* Cantos arredondados */
        }

        .game-button:hover:not(:disabled) {
            background-color: #3182ce; /* Azul mais escuro ao passar o mouse */
            transform: translateY(-2px);
        }

        .game-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .game-button:disabled {
            background-color: #6b7280; /* Cinza para desabilitado */
            cursor: not-allowed;
            opacity: 0.7;
        }

        .main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6vmin; /* Alterado para vmin */
            max-width: 500px;
            width: 90%;
            text-align: center;
            background-color: rgba(26, 32, 44, 0.8); /* Fundo semi-transparente para o menu */
            z-index: 1; /* Garante que esteja acima do fundo */
            border-radius: 1rem; /* Cantos arredondados */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5); /* Sombra */
        }

        .menu-button {
            background-color: #48bb78; /* Botão verde */
            color: white;
            padding: 2.5vmin 5vmin; /* Alterado para vmin */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
            width: 80%;
            margin-bottom: 1.5vmin; /* Margem responsiva */
            border-radius: 0.5rem; /* Cantos arredondados */
        }

        .menu-button:hover {
            background-color: #38a169; /* Verde mais escuro ao passar o mouse */
            transform: translateY(-3px);
        }

        .menu-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px (0, 0, 0, 0.3);
        }

        /* O seletor de dificuldade agora está oculto */
        .difficulty-selector {
            display: none; /* Oculta todo o seletor de dificuldade */
        }

        /* Modal de Promoção de Peão */
        .promotion-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            padding: 4vmin; /* Alterado para vmin */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            border: 0.25vmin solid #4a5568; /* Alterado para vmin */
            border-radius: 1rem; /* Cantos arredondados */
        }

        .promotion-modal h3 {
            font-size: 4vmin; /* Alterado para vmin */
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 10px;
        }

        .promotion-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap; /* Permite que as opções quebrem */
            justify-content: center;
        }

        .promotion-button {
            background-color: #48bb78; /* Botão verde */
            color: white;
            padding: 2.5vmin; /* Alterado para vmin */
            font-size: 4vmin; /* Alterado para vmin */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            border: none;
            width: 10vmin; /* Alterado para vmin */
            height: 10vmin; /* Alterado para vmin */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.5rem; /* Cantos arredondados */
        }

        .promotion-button:hover {
            background-color: #38a169; /* Verde mais escuro ao passar o mouse */
            transform: translateY(-3px);
        }

        .promotion-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px (0, 0, 0, 0.3);
        }

        /* Ajustes responsivos para o modal de promoção (media query original, ainda útil) */
        @media (max-width: 600px) {
            .promotion-modal {
                padding: 15px;
                width: 90%;
            }
            .promotion-modal h3 {
                font-size: 1.4rem;
            }
            .promotion-options {
                flex-wrap: wrap;
                justify-content: center;
            }
            .promotion-button {
                width: 55px;
                height: 55px;
                font-size: 2rem;
                padding: 10px;
            }
            .piece {
            font-size: 7vmin; /* Alterado de 30px para 8vmin */
        }
        }

        /* Estilos para o efeito de explosão */
        .explosion {
            position: absolute;
            width: 100%; /* Ocupa a largura da casa */
            height: 100%; /* Ocupa a altura da casa */
            background-color: rgba(255, 165, 0, 0.8); /* Laranja semi-transparente */
            border-radius: 50%; /* Forma circular */
            transform: scale(0); /* Começa invisível */
            opacity: 0; /* Começa transparente */
            animation: explode 0.4s ease-out forwards; /* Animação de explosão */
            pointer-events: none; /* Não interfere com cliques no tabuleiro */
            z-index: 50; /* Garante que esteja acima das peças */
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 0;
                background-color: rgba(255, 165, 0, 0.8);
            }
            50% {
                transform: scale(1.5); /* Expande para 150% do tamanho */
                opacity: 1; /* Totalmente visível */
                background-color: rgba(255, 69, 0, 0.9); /* Vermelho alaranjado */
            }
            100% {
                transform: scale(2); /* Continua a expandir */
                opacity: 0; /* Desaparece */
                background-color: rgba(255, 255, 0, 0); /* Transparente */
            }
        }

        /* Media query para a resolução entre 700px e 1023px de largura e 866px de altura */
        @media (min-width: 630px) and (max-width: 1023px) and (min-height: 866px) {
            .chessboard {
            width:60%;
        }
        .piece {
            font-size: 4vmin; /* Alterado de 30px para 8vmin */
        }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">
    <!-- Tela de Carregamento -->
    <div id="loadingScreen">
        <div class="spinner"></div>
        <span>Carregando Jogo...</span>
    </div>

    <!-- Background para a tela inicial -->
    <div id="mainMenuBackground" class="absolute inset-0 bg-cover bg-center bg-no-repeat hidden" style="background-image: url('https://dl.dropbox.com/scl/fi/3uw0rjjq8myl63qfpifkn/Xadrez.png?rlkey=elzhai342zvi7i2dh9udvcbwi&st=5ir07uua&dl=0');"></div>

    <!-- Seção do Menu Principal -->
    <div id="mainMenu" class="main-menu z-10 hidden">
        <h1 class="text-3xl font-bold mb-8 text-white">Jogo de Xadrez</h1>
        <button id="playVsComputerBtn" class="menu-button text-2xl">Um Jogador</button>
        <button id="playVsPlayerBtn" class="menu-button text-2xl">Dois Jogadores</button>
    </div>

    <!-- Novo contêiner para o layout do jogo (tabuleiro + controles) -->
    <div id="gameLayout" class="flex flex-col lg:flex-row items-center justify-center gap-8 p-4 w-full max-w-screen-xl mx-auto hidden z-10">

        <!-- Painel de Informações e Controles do Jogo -->
        <div id="gameControls">
            <div class="control-buttons mt-auto">
                <button id="undoButton" class="game-button text-2xl">Voltar Jogada</button>
                <button id="redoButton" class="game-button text-2xl">Prosseguir Jogada</button>
                <button id="resetButton" class="game-button text-2xl">Reiniciar Jogo</button>
                <button id="backToMenuButton" class="game-button text-2xl">Voltar ao Menu</button>
            </div>
            <br>
            <div id="status" class="status-message mb-auto text-2xl">Vez das Brancas</div>
        </div>

        <!-- Contêiner do Jogo (agora exclusivamente para o tabuleiro) -->
        <div id="gameContainer" class="game-container">
            <div id="chessboard" class="chessboard"></div>
            <!-- Modal de Promoção de Peão (permanece dentro do gameContainer para posicionamento relativo) -->
            <div id="promotionModal" class="promotion-modal hidden">
                <h3>Escolha a peça para promoção:</h3>
                <div class="promotion-options" id="promotionOptions">
                    <!-- Os botões de promoção serão inseridos aqui pelo JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Caracteres Unicode das peças de xadrez
        const PIECES = {
            'K': '&#9812;', 'Q': '&#9813;', 'R': '&#9814;', 'B': '&#9815;', 'N': '&#9816;', 'P': '&#9817;', // Brancas
            'k': '&#9818;', 'q': '&#9819;', 'r': '&#9820;', 'b': '&#9821;', 'n': '&#9822;', 'p': '&#9823;'  // Pretas
        };

        // Configuração inicial do tabuleiro (representação tipo FEN string)
        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let board = []; // Estado atual do tabuleiro
        let selectedPiece = null; // Armazena a posição da peça atualmente selecionada [linha, coluna]
        let currentPlayer = 'white'; // 'white' ou 'black'
        let gameOver = false;
        let gameMode = 'player'; // 'player' ou 'computer'
        let isThinking = false; // Flag para impedir a entrada do usuário enquanto a IA está pensando
        let aiSearchDepth = 2; // Profundidade de busca da IA padrão (Normal) - agora fixa

        // Flags de roque
        let whiteKingMoved = false;
        let blackKingMoved = false;
        let whiteRookLeftMoved = false; // Torre em (7,0)
        let whiteRookRightMoved = false; // Torre em (7,7)
        let blackRookLeftMoved = false; // Torre em (0,0)
        let blackRookRightMoved = false; // Torre em (0,7)

        let gameHistory = []; // Array para armazenar estados anteriores do jogo
        let historyPointer = -1; // Índice do estado atual no gameHistory

        let promotionTarget = null; // Armazena [linha, coluna] para promoção de peão

        const loadingScreenElement = document.getElementById('loadingScreen'); // Novo elemento
        const mainMenuElement = document.getElementById('mainMenu');
        const gameLayoutElement = document.getElementById('gameLayout'); // Novo elemento para o layout principal do jogo
        const gameContainerElement = document.getElementById('gameContainer'); // Agora contém apenas o tabuleiro
        const chessboardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const backToMenuButton = document.getElementById('backToMenuButton');
        const playVsComputerBtn = document.getElementById('playVsComputerBtn');
        const playVsPlayerBtn = document.getElementById('playVsPlayerBtn');
        const promotionModal = document.getElementById('promotionModal');
        const promotionOptions = document.getElementById('promotionOptions');
        const mainMenuBackgroundElement = document.getElementById('mainMenuBackground');
        const BACKGROUND_IMAGE_URL = 'https://dl.dropbox.com/scl/fi/3uw0rjjq8myl63qfpifkn/Xadrez.png?rlkey=elzhai342zvi7i2dh9udvcbwi&st=5ir07uua&dl=0'; // URL da imagem de fundo

        // Valores das peças para a função de avaliação (Sinais corrigidos para a perspectiva da IA - Preto é o jogador maximizador)
        const PIECE_VALUES = {
            'P': -20000,  // Peão Branco: -1 ponto (negativo porque é ruim para o preto)
            'N': -70000,  // Cavalo Branco: -3.5 pontos
            'B': -70000,  // Bispo Branco: -3.5 pontos
            'R': -120000, // Torre Branca: -6 pontos
            'Q': -220000, // Rainha Branca: -11 pontos
            'K': -1000000000, // Rei Branco: Inestimável (grande negativo para evitar captura do rei)

            'p': 20000,   // Peão Preto: +1 ponto (positivo porque é bom para o preto)
            'n': 70000,   // Cavalo Preto: +3.5 pontos
            'b': 70000,   // Bispo Preto: +3.5 pontos
            'r': 120000,  // Torre Preta: +6 pontos
            'q': 220000, // Rainha Preta: +11 pontos
            'k': 1000000000 // Rei Preto: Inestimável
        };

        // Tabelas de posição das peças (exemplo, podem ser refinadas)
        // Os valores são adicionados ao valor base da peça. Positivo para branco, negativo para preto.
        const PAWN_POSITION_TABLE = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [5, 5, 10, 25, 25, 10, 5, 5],
            [0, 0, 0, 20, 20, 0, 0, 0],
            [5, -5, -10, 0, 0, -10, -5, 5],
            [5, 10, 10, -20, -20, 10, 10, 5],
            [0, 0, 0, 0, 0, 0, 0, 0]
        ];

        const KNIGHT_POSITION_TABLE = [
            [-50, -40, -30, -30, -30, -30, -40, -50],
            [-40, -20, 0, 0, 0, 0, -20, -40],
            [-30, 0, 10, 15, 15, 10, 0, -30],
            [-30, 5, 15, 20, 20, 15, 5, -30],
            [-30, 0, 15, 20, 20, 15, 0, -30],
            [-30, 5, 10, 15, 15, 10, 5, -30],
            [-40, -20, 0, 5, 5, 0, -20, -40],
            [-50, -40, -30, -30, -30, -30, -30, -50]
        ];

        const BISHOP_POSITION_TABLE = [
            [-20, -10, -10, -10, -10, -10, -10, -20],
            [-10, 0, 0, 0, 0, 0, 0, -10],
            [-10, 0, 5, 10, 10, 5, 0, -10],
            [-10, 5, 5, 10, 10, 5, 5, -10],
            [-10, 0, 10, 10, 10, 10, 0, -10],
            [-10, 10, 10, 10, 10, 10, 10, -10],
            [-10, 5, 0, 0, 0, 0, 5, -10],
            [-20, -10, -10, -10, -10, -10, -10, -20]
        ];

        const ROOK_POSITION_TABLE = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [5, 10, 10, 10, 10, 10, 10, 5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [0, 0, 0, 5, 5, 0, 0, 0]
        ];

        const QUEEN_POSITION_TABLE = [
            [-20, -10, -10, -5, -5, -10, -10, -20],
            [-10, 0, 0, 0, 0, 0, 0, -10],
            [-10, 0, 5, 5, 5, 5, 0, -10],
            [-5, 0, 5, 5, 5, 5, 0, -5],
            [0, 0, 5, 5, 5, 5, 0, -5],
            [-10, 5, 5, 5, 5, 5, 0, -10],
            [-10, 0, 5, 0, 0, 0, 0, -10],
            [-20, -10, -10, -5, -5, -10, -10, -20]
        ];

        const KING_POSITION_TABLE_MIDDLE_GAME = [
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-20, -30, -30, -40, -40, -30, -30, -20],
            [-10, -20, -20, -20, -20, -20, -20, -10],
            [20, 20, 0, 0, 0, 0, 20, 20],
            [20, 30, 10, 0, 0, 10, 30, 20]
        ];

        const KING_POSITION_TABLE_END_GAME = [
            [-50, -40, -30, -20, -20, -30, -40, -50],
            [-30, -20, -10, 0, 0, -10, -20, -30],
            [-30, -10, 20, 30, 30, 20, -10, -30],
            [-30, -10, 30, 40, 40, 30, -10, -30],
            [-30, -10, 30, 40, 40, 30, -10, -30],
            [-30, -10, 20, 30, 30, 20, -10, -30],
            [-30, -20, -10, 0, 0, -10, -20, -30],
            [-50, -40, -30, -20, -20, -30, -40, -50]
        ];


        // --- Zobrist Hashing e Tabela de Transposição ---
        const ZOBRIST_TABLE = {};
        let currentZobristHash = 0;
        const transpositionTable = new Map(); // Armazena {hash: {evaluation, depth, bestMove}}

        /**
         * Gera um inteiro aleatório de 32 bits.
         * @returns {number} Um inteiro aleatório de 32 bits.
         */
        function getRandom32BitInt() {
            return (Math.random() * 0x100000000) | 0; // Gera um inteiro de 32 bits
        }

        /**
         * Inicializa a tabela Zobrist com números aleatórios para cada peça em cada casa.
         * Também inicializa números aleatórios para direitos de roque, arquivo en passant e turno.
         */
        function initializeZobristTable() {
            // Peças nas casas
            for (const pieceType in PIECES) {
                ZOBRIST_TABLE[pieceType] = [];
                for (let r = 0; r < 8; r++) {
                    ZOBRIST_TABLE[pieceType][r] = [];
                    for (let c = 0; c < 8; c++) {
                        ZOBRIST_TABLE[pieceType][r][c] = getRandom32BitInt();
                    }
                }
            }

            // Direitos de roque (Rei Branco, Rainha Branca, Rei Preto, Rainha Preta)
            ZOBRIST_TABLE.castling = {
                'WK': getRandom32BitInt(),
                'WQ': getRandom32BitInt(),
                'BK': getRandom32BitInt(),
                'BQ': getRandom32BitInt()
            };

            // Para mover (Branco ou Preto)
            ZOBRIST_TABLE.turn = {
                'white': getRandom32BitInt(),
                'black': getRandom32BitInt()
            };
            // Nota: En passant não está totalmente implementado em Zobrist para simplificação nesta versão.
        }

        /**
         * Calcula o hash Zobrist para um dado estado do tabuleiro.
         * Esta função deve ser usada no início do minimax para fazer o hash do estado atual do tabuleiro.
         * @param {Array<Array<string>>} boardState - O estado do tabuleiro para fazer o hash.
         * @param {string} playerTurn - O jogador cujo turno é ('white' ou 'black').
         * @param {object} castlingFlags - Objeto com as flags de roque atuais (whiteKingMoved, etc.).
         * @returns {number} O hash Zobrist para o estado do tabuleiro dado.
         */
        function calculateBoardHash(boardState, playerTurn, castlingFlags) {
            let hash = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c];
                    if (piece) {
                        hash ^= ZOBRIST_TABLE[piece][r][c];
                    }
                }
            }

            // Adiciona direitos de roque ao hash
            if (!castlingFlags.whiteKingMoved && !castlingFlags.whiteRookRightMoved) hash ^= ZOBRIST_TABLE.castling['WK'];
            if (!castlingFlags.whiteKingMoved && !castlingFlags.whiteRookLeftMoved) hash ^= ZOBRIST_TABLE.castling['WQ'];
            if (!castlingFlags.blackKingMoved && !castlingFlags.blackRookRightMoved) hash ^= ZOBRIST_TABLE.castling['BK'];
            if (!castlingFlags.blackKingMoved && !castlingFlags.blackRookLeftMoved) hash ^= ZOBRIST_TABLE.castling['BQ'];

            // Adiciona turno ao hash
            hash ^= ZOBRIST_TABLE.turn[playerTurn];

            return hash;
        }

        // --- Fim da Configuração de Hashing Zobrist e Tabela de Transposição ---

        /**
         * Mostra o menu principal e oculta o contêiner do jogo.
         */
        function showMainMenu() {
            mainMenuElement.classList.remove('hidden');
            mainMenuElement.style.display = 'flex'; // Garante que o menu principal seja exibido como flex

            gameLayoutElement.classList.add('hidden');
            gameLayoutElement.style.display = 'none'; // Garante que o layout do jogo esteja oculto

            mainMenuBackgroundElement.classList.remove('hidden'); // Mostra o fundo da tela inicial
        }

        /**
         * Mostra o contêiner do jogo e oculta o menu principal.
         */
        function showGame() {
            mainMenuElement.classList.add('hidden');
            mainMenuElement.style.display = 'none'; // Garante que o menu principal esteja oculto

            gameLayoutElement.classList.remove('hidden');
            gameLayoutElement.style.display = 'flex'; // Garante que o layout do jogo seja exibido como flex

            mainMenuBackgroundElement.classList.add('hidden'); // Oculta o fundo da tela inicial
        }

        /**
         * Salva o estado atual do jogo no localStorage.
         */
        function saveGameToLocalStorage() {
            const gameState = {
                board: board,
                currentPlayer: currentPlayer,
                gameOver: gameOver,
                whiteKingMoved: whiteKingMoved,
                blackKingMoved: blackKingMoved,
                whiteRookLeftMoved: whiteRookLeftMoved,
                whiteRookRightMoved: whiteRookRightMoved,
                blackRookLeftMoved: blackRookLeftMoved,
                blackRookRightMoved: blackRookRightMoved,
                gameHistory: gameHistory, // Salva todo o histórico para desfazer/refazer
                historyPointer: historyPointer,
                gameMode: gameMode, // Este será o modo que estava ativo quando salvo
                aiSearchDepth: aiSearchDepth
            };
            try {
                // Usa uma chave específica para o modo de jogo atual
                localStorage.setItem(`chessGame_${gameMode}`, JSON.stringify(gameState));
                console.log(`Estado do jogo para ${gameMode} salvo no localStorage.`);
            } catch (e) {
                console.error('Erro ao salvar o jogo no localStorage:', e);
            }
        }

        /**
         * Carrega o estado do jogo do localStorage para um modo específico.
         * @param {string} modeToLoad - O modo de jogo a ser carregado ('computer' ou 'player').
         * @returns {boolean} True se um jogo foi carregado com sucesso, false caso contrário.
         */
        function loadGameFromLocalStorage(modeToLoad) {
            try {
                const savedGame = localStorage.getItem(`chessGame_${modeToLoad}`);
                if (savedGame) {
                    const gameState = JSON.parse(savedGame);
                    board = gameState.board;
                    currentPlayer = gameState.currentPlayer;
                    gameOver = gameState.gameOver;
                    whiteKingMoved = gameState.whiteKingMoved;
                    blackKingMoved = gameState.blackKingMoved;
                    whiteRookLeftMoved = gameState.whiteRookLeftMoved;
                    whiteRookRightMoved = gameState.whiteRookRightMoved;
                    blackRookLeftMoved = gameState.blackRookLeftMoved;
                    blackRookRightMoved = gameState.blackRookRightMoved;
                    gameHistory = gameState.gameHistory;
                    historyPointer = gameState.historyPointer;
                    gameMode = modeToLoad; // Define o gameMode para o que foi carregado
                    aiSearchDepth = gameState.aiSearchDepth || 2; // Garante que aiSearchDepth seja definido, padrão para 2

                    // Recalcula o hash Zobrist após carregar o tabuleiro
                    currentZobristHash = calculateBoardHash(board, currentPlayer, {
                        whiteKingMoved, blackKingMoved, whiteRookLeftMoved, whiteRookRightMoved, blackRookLeftMoved, blackRookRightMoved
                    });

                    renderBoard();
                    updateStatus();
                    updateHistoryButtons();
                    console.log(`Estado do jogo para ${modeToLoad} carregado do localStorage.`);

                    // Aplica a rotação do tabuleiro com base no jogador carregado (sem animação, pois foi removida)
                    applyBoardRotation(currentPlayer);


                    // Se for a vez da IA após o carregamento, a IA faz a jogada
                    if (!gameOver && gameMode === 'computer' && currentPlayer === 'black') {
                        isThinking = true;
                        statusElement.textContent = "Computador pensando...";
                        updateHistoryButtons();
                        setTimeout(makeComputerMove, 500);
                    }
                    return true; // Jogo carregado com sucesso
                }
            } catch (e) {
                console.error('Erro ao carregar o jogo no localStorage:', e);
                localStorage.removeItem(`chessGame_${modeToLoad}`); // Limpa dados corrompidos para aquele modo
            }
            return false; // Nenhum jogo carregado
        }

        /**
         * Inicializa um novo tabuleiro de jogo e o renderiza para um modo específico.
         * Esta função sempre inicia um novo jogo, descartando qualquer estado anterior para aquele modo.
         * @param {string} mode - 'computer' ou 'player'
         */
        function initializeNewGame(mode) {
            board = JSON.parse(JSON.stringify(initialBoard)); // Copia profundamente o tabuleiro inicial
            selectedPiece = null;
            currentPlayer = 'white';
            gameOver = false;
            gameMode = mode; // Define o modo de jogo
            isThinking = false; // Reseta a flag de pensamento
            aiSearchDepth = 2; // Profundidade de busca da IA fixada para Normal (2)

            // Reseta as flags de roque
            whiteKingMoved = false;
            blackKingMoved = false;
            whiteRookLeftMoved = false;
            whiteRookRightMoved = false;
            blackRookLeftMoved = false;
            blackRookRightMoved = false;

            gameHistory = []; // Limpa o histórico
            historyPointer = -1; // Reseta o ponteiro
            transpositionTable.clear(); // Limpa a tabela de transposição para um novo jogo

            // A tabela Zobrist é inicializada uma vez em DOMContentLoaded, não há necessidade de reinicializar aqui
            // Recalcula o hash inicial com base no estado do tabuleiro inicial e nas flags
            currentZobristHash = calculateBoardHash(board, currentPlayer, {
                whiteKingMoved, blackKingMoved, whiteRookLeftMoved, whiteRookRightMoved, blackRookLeftMoved, blackRookRightMoved
            });

            saveCurrentState(); // Salva este novo estado inicial
            renderBoard();
            updateStatus();
            updateHistoryButtons();

            // Garante que o tabuleiro não esteja rotacionado no início de um novo jogo
            applyBoardRotation(currentPlayer); // Aplica a rotação inicial (que agora é instantânea)

            // Se iniciar contra o computador, e for a vez das pretas (vez da IA), a IA faz a jogada
            if (gameMode === 'computer' && currentPlayer === 'black') {
                setTimeout(makeComputerMove, 500); // Pequeno atraso para melhor UX
            }
        }

        /**
         * Inicia um jogo em um modo específico. Ele tenta carregar um jogo salvo para aquele modo primeiro.
         * Se nenhum jogo salvo existir, ele inicializa um novo.
         * @param {string} mode - 'computer' ou 'player'
         */
        function startGameMode(mode) {
            if (!loadGameFromLocalStorage(mode)) { // Tenta carregar
                initializeNewGame(mode); // Se nenhum jogo salvo, inicia um novo
            }
            showGame(); // Sempre mostra o tabuleiro do jogo após tentar carregar/inicializar
        }


        /**
         * Salva o estado atual do jogo no histórico.
         * Se novas jogadas forem feitas após desfazer, isso trunca o histórico "futuro".
         */
        function saveCurrentState() {
            // Se desfizermos jogadas, truncamos o histórico para o ponteiro atual
            if (historyPointer < gameHistory.length - 1) {
                gameHistory = gameHistory.slice(0, historyPointer + 1);
            }
            gameHistory.push({
                board: JSON.parse(JSON.stringify(board)), // Copia profundamente o tabuleiro
                currentPlayer: currentPlayer,
                gameOver: gameOver,
                whiteKingMoved: whiteKingMoved,
                blackKingMoved: blackKingMoved,
                whiteRookLeftMoved: whiteRookLeftMoved,
                whiteRookRightMoved: whiteRookRightMoved,
                blackRookLeftMoved: blackRookLeftMoved,
                blackRookRightMoved: blackRookRightMoved,
                zobristHash: currentZobristHash // Salva o hash Zobrist atual
            });
            historyPointer++;
            updateHistoryButtons();
            saveGameToLocalStorage(); // Salva no localStorage após cada mudança de estado
        }

        /**
         * Carrega um estado de jogo específico do histórico.
         * @param {number} index - O índice do estado a ser carregado.
         */
        function loadState(index) {
            if (index >= 0 && index < gameHistory.length) {
                const state = gameHistory[index];
                board = JSON.parse(JSON.stringify(state.board));
                currentPlayer = state.currentPlayer;
                gameOver = state.gameOver;
                whiteKingMoved = state.whiteKingMoved;
                blackKingMoved = state.blackKingMoved;
                whiteRookLeftMoved = state.whiteRookLeftMoved;
                whiteRookRightMoved = state.whiteRookRightMoved;
                blackRookLeftMoved = state.blackRookLeftMoved;
                blackRookRightMoved = state.blackRookRightMoved;
                currentZobristHash = state.zobristHash; // Carrega o hash Zobrist

                selectedPiece = null; // Desseleciona qualquer peça ao carregar o estado
                renderBoard();
                updateStatus();
                updateHistoryButtons();
                saveGameToLocalStorage(); // Salva no localStorage após carregar um estado histórico

                // Aplica a rotação do tabuleiro com base no jogador carregado (sem animação)
                applyBoardRotation(currentPlayer);
            }
        }

        /**
         * Desfaz a última jogada.
         */
        function undoMove() {
            if (historyPointer > 0) {
                historyPointer--;
                loadState(historyPointer);
            }
        }

        /**
         * Refaz uma jogada previamente desfeita.
         */
        function redoMove() {
            if (historyPointer < gameHistory.length - 1) {
                historyPointer++;
                loadState(historyPointer);
            }
        }

        /**
         * Atualiza o estado habilitado/desabilitado dos botões de desfazer/refazer.
         */
        function updateHistoryButtons() {
            undoButton.disabled = historyPointer <= 0 || isThinking;
            redoButton.disabled = historyPointer >= gameHistory.length - 1 || isThinking;
            // Também desabilita toda a interação do tabuleiro se o jogo acabou ou a IA está pensando ou o modal de promoção está aberto
            if (gameOver || isThinking || !promotionModal.classList.contains('hidden')) {
                chessboardElement.style.pointerEvents = 'none';
            } else {
                chessboardElement.style.pointerEvents = 'auto';
            }
        }

        /**
         * Renderiza o tabuleiro de xadrez com base no estado 'board' atual.
         * Esta função é usada para a renderização inicial e ao carregar estados do histórico.
         * Os movimentos individuais são manipulados diretamente no DOM para animação.
         */
        function renderBoard() {
            chessboardElement.innerHTML = ''; // Limpa o tabuleiro existente
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.classList.add('square', (row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const piece = board[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.classList.add('piece', isWhitePiece(piece) ? 'white-piece' : 'black-piece');
                        pieceElement.innerHTML = PIECES[piece];

                        // Aplica a rotação inicial da peça para que ela esteja sempre na vertical
                        // Isso será ajustado por applyBoardRotation para o jogador atual
                        pieceElement.style.transform = 'rotate(0deg)';

                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', handleSquareClick);
                    chessboardElement.appendChild(square);
                }
            }
        }

        /**
         * Lida com um evento de clique em uma casa do tabuleiro de xadrez.
         * @param {Event} event - O evento de clique.
         */
        function handleSquareClick(event) {
            // Impede movimentos se o jogo acabou ou a IA está pensando ou o modal de promoção está aberto
            if (gameOver || isThinking || !promotionModal.classList.contains('hidden')) return;

            const targetSquare = event.currentTarget;
            const row = parseInt(targetSquare.dataset.row);
            const col = parseInt(targetSquare.dataset.col);
            const pieceAtSquare = board[row][col];

            // Se uma peça já estiver selecionada
            if (selectedPiece) {
                const [prevRow, prevCol] = selectedPiece;
                const prevPiece = board[prevRow][prevCol];

                // Se clicar na mesma peça selecionada, desseleciona-a
                if (row === prevRow && col === prevCol) {
                    deselectPiece();
                    return;
                }

                // Verifica tentativa de roque (Rei selecionado, alvo é uma casa de destino de roque)
                if (prevPiece.toLowerCase() === 'k') {
                    let rookCol = -1; // Inicializa com uma coluna inválida

                    // Roque do lado do rei (Rei move para g1/g8)
                    if ((isWhitePiece(prevPiece) && prevRow === 7 && prevCol === 4 && row === 7 && col === 6) ||
                        (isBlackPiece(prevPiece) && prevRow === 0 && prevCol === 4 && row === 0 && col === 6)) {
                        rookCol = 7; // Coluna da torre do lado do rei
                    }
                    // Roque do lado da rainha (Rei move para c1/c8)
                    else if ((isWhitePiece(prevPiece) && prevRow === 7 && prevCol === 4 && row === 7 && col === 2) ||
                             (isBlackPiece(prevPiece) && prevRow === 0 && prevCol === 4 && row === 0 && col === 2)) {
                        rookCol = 0; // Coluna da torre do lado da rainha
                    }

                    if (rookCol !== -1) { // Se for uma casa de destino de roque
                        if (isValidCastling(prevRow, prevCol, row, rookCol)) { // Passa a linha de destino do rei e a coluna original da torre
                            makeCastlingMove(prevRow, prevCol, row, rookCol);
                            deselectPiece();
                            // A troca de jogador e o salvamento do estado ocorrem APÓS a animação em makeCastlingMove
                            return; // A jogada de roque foi feita, sai do manipulador
                        }
                    }
                }

                // Tenta mover a peça selecionada (movimento regular)
                if (isValidMove(prevPiece, prevRow, prevCol, row, col)) {
                    makeMove(prevRow, prevCol, row, col);
                    // A promoção, troca de jogador e salvamento do estado ocorrem APÓS a animação em makeMove
                } else {
                    // Se clicar em uma nova peça da cor do jogador atual, seleciona-a
                    if (pieceAtSquare && isCurrentPlayerPiece(pieceAtSquare)) {
                        deselectPiece(); // Desseleciona a anterior primeiro
                        selectPiece(row, col);
                    } else {
                        // Movimento inválido ou clicando na peça do oponente sem movimento válido
                        deselectPiece();
                    }
                }
            } else {
                // Nenhuma peça selecionada ainda, tenta selecionar uma
                if (pieceAtSquare && isCurrentPlayerPiece(pieceAtSquare)) {
                    selectPiece(row, col);
                }
            }
        }

        /**
         * Exibe o modal de promoção de peão.
         * @param {boolean} isWhitePawn - True se o peão for branco, false se for preto.
         */
        function showPromotionModal(isWhitePawn) {
            promotionModal.classList.remove('hidden');
            promotionOptions.innerHTML = ''; // Limpa opções anteriores

            const piecesToPromoteTo = ['Q', 'R', 'B', 'N']; // Rainha, Torre, Bispo, Cavalo
            const pieceColors = isWhitePawn ? piecesToPromoteTo : piecesToPromoteTo.map(p => p.toLowerCase());

            pieceColors.forEach(pieceChar => {
                const button = document.createElement('button');
                button.classList.add('promotion-button');
                button.innerHTML = PIECES[pieceChar];
                button.dataset.piece = pieceChar;
                button.addEventListener('click', () => handlePawnPromotion(pieceChar));
                promotionOptions.appendChild(button);
            });

            // Desabilita a interação do tabuleiro enquanto o modal estiver aberto
            chessboardElement.style.pointerEvents = 'none';
            updateHistoryButtons(); // Atualiza o estado dos botões
        }

        /**
         * Lida com a escolha de promoção de peão.
         * @param {string} chosenPiece - O caractere da peça escolhida (ex: 'Q', 'r').
         */
        function handlePawnPromotion(chosenPiece) {
            if (!promotionTarget) return; // Não deveria acontecer

            const [row, col] = promotionTarget;
            const originalPawn = board[row][col]; // Obtém o peão antes da promoção

            // Atualiza o hash Zobrist: XOR do peão, XOR da nova peça
            currentZobristHash ^= ZOBRIST_TABLE[originalPawn][row][col];
            currentZobristHash ^= ZOBRIST_TABLE[chosenPiece][row][col];

            board[row][col] = chosenPiece; // Promove o peão

            // Atualiza o elemento da peça no DOM
            const promotedSquareElement = chessboardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const pieceElement = promotedSquareElement.querySelector('.piece');
            if (pieceElement) {
                pieceElement.innerHTML = PIECES[chosenPiece];
                pieceElement.className = ''; // Limpa as classes existentes
                pieceElement.classList.add('piece', isWhitePiece(chosenPiece) ? 'white-piece' : 'black-piece');
                // Garante que a peça promovida esteja na vertical
                pieceElement.style.transform = (gameMode === 'player' && currentPlayer === 'black') ? 'rotate(180deg)' : 'rotate(0deg)';
            }

            promotionModal.classList.add('hidden'); // Oculta o modal
            chessboardElement.style.pointerEvents = 'auto'; // Reabilita a interação do tabuleiro
            promotionTarget = null; // Limpa o alvo de promoção

            deselectPiece(); // Garante que nenhuma peça esteja selecionada após a promoção
            switchPlayer(); // Troca para o próximo jogador
            saveCurrentState(); // Salva o estado após a promoção
        }


        /**
         * Seleciona uma peça na linha e coluna dadas.
         * Destaca a casa selecionada e os movimentos possíveis.
         * @param {number} row - A linha da peça.
         * @param {number} col - A coluna da peça.
         */
        function selectPiece(row, col) {
            selectedPiece = [row, col];
            const squareElement = chessboardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            squareElement.classList.add('selected');

            // Destaca movimentos possíveis (apenas movimentos legais)
            const piece = board[row][col];
            const legalMoves = getLegalMoves(piece, row, col); // Usa getLegalMoves aqui
            legalMoves.forEach(([r, c]) => {
                chessboardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`).classList.add('possible-move');
            });
        }

        /**
         * Desseleciona a peça atualmente selecionada.
         * Remove os destaques da casa selecionada e dos movimentos possíveis.
         */
        function deselectPiece() {
            if (selectedPiece) {
                const [prevRow, prevCol] = selectedPiece;
                chessboardElement.querySelector(`[data-row="${prevRow}"][data-col="${prevCol}"]`).classList.remove('selected');
                selectedPiece = null;
            }
            // Remove todos os destaques de movimentos possíveis
            document.querySelectorAll('.possible-move').forEach(sq => sq.classList.remove('possible-move'));
        }

        /**
         * Verifica se uma peça pertence ao jogador atual.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça pertence ao jogador atual.
         */
        function isCurrentPlayerPiece(piece) {
            return (currentPlayer === 'white' && isWhitePiece(piece)) ||
                   (currentPlayer === 'black' && isBlackPiece(piece));
        }

        /**
         * Verifica se uma peça é branca.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça é branca.
         */
        function isWhitePiece(piece) {
            return piece === piece.toUpperCase();
        }

        /**
         * Verifica se uma peça é preta.
         * @param {string} piece - O caractere da peça.
         * @returns {boolean} - True se a peça é preta.
         */
        function isBlackPiece(piece) {
            return piece === piece.toLowerCase();
        }

        // Inicializa o Tone.Player para o som de captura
        let captureSoundPlayer;
        let moveSoundPlayer; // Novo player para o som de movimento
        let checkSoundPlayer; // Novo player para o som de xeque
        let checkmateSoundPlayer; // Novo player para o som de xeque-mate

        document.addEventListener('DOMContentLoaded', () => {
            captureSoundPlayer = new Tone.Player({
                url: "https://dl.dropbox.com/scl/fi/3oi7r4pwkef5fyvpz0ake/sword-slash-and-swing-185432.mp3?rlkey=wr2uuldegryfofsspu849i51d&st=l3v9qgdy&dl=0", // URL atualizado
                onload: () => console.log("Capture sound loaded!"),
                onerror: (e) => console.error("Error loading capture sound:", e)
            }).toDestination();

            // Inicializa o Tone.Player para o som de movimento
            moveSoundPlayer = new Tone.Player({
                url: "https://dl.dropbox.com/scl/fi/a7lzwyo5o3ll87l5vu77j/wood-block-105066.mp3?rlkey=6fbvepxo0e48lrc9do48q3xts&st=38krftjs&dl=0", // URL atualizado
                onload: () => console.log("Move sound loaded!"),
                onerror: (e) => console.error("Error loading move sound:", e)
            }).toDestination();

            // Inicializa o Tone.Player para o som de xeque
            checkSoundPlayer = new Tone.Player({
                url: "https://dl.dropbox.com/scl/fi/pn27sxasgcwrvs8vh1jod/ding-sound-effect_2.mp3?rlkey=uekjc19kwjjb0wked1orjt314&st=tlgzsdn8&dl=0",
                onload: () => console.log("Check sound loaded!"),
                onerror: (e) => console.error("Error loading check sound:", e)
            }).toDestination();

            // Inicializa o Tone.Player para o som de xeque-mate
            checkmateSoundPlayer = new Tone.Player({
                url: "https://dl.dropbox.com/scl/fi/qo8aicopyzour11ly3e8w/taco-bell-bong-sfx.mp3?rlkey=qz007si0s61vr6pwwp6r0fge4&st=dyxvpj8a&dl=0", // URL do som de xeque-mate
                onload: () => console.log("Checkmate sound loaded!"),
                onerror: (e) => console.error("Error loading checkmate sound:", e)
            }).toDestination();
        });

        /**
         * Toca o som de captura.
         */
        function playCaptureSound() {
            // Garante que o contexto de áudio esteja ativo antes de tocar
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            if (captureSoundPlayer && captureSoundPlayer.loaded) {
                captureSoundPlayer.start();
            } else {
                console.warn("Capture sound not loaded yet or player not initialized.");
            }
        }

        /**
         * Toca o som de movimento.
         */
        function playMoveSound() {
            // Garante que o contexto de áudio esteja ativo antes de tocar
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            if (moveSoundPlayer && moveSoundPlayer.loaded) {
                moveSoundPlayer.start();
            } else {
                console.warn("Move sound not loaded yet or player not initialized.");
            }
        }

        /**
         * Toca o som de xeque.
         */
        function playCheckSound() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            if (checkSoundPlayer && checkSoundPlayer.loaded) {
                checkSoundPlayer.start();
            } else {
                console.warn("Check sound not loaded yet or player not initialized.");
            }
        }

        /**
         * Toca o som de xeque-mate.
         */
        function playCheckmateSound() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            if (checkmateSoundPlayer && checkmateSoundPlayer.loaded) {
                checkmateSoundPlayer.start();
            } else {
                console.warn("Checkmate sound not loaded yet or player not initialized.");
            }
        }

        /**
         * Faz um movimento no tabuleiro com animação.
         * @param {number} fromRow - Linha de partida.
         * @param {number} fromCol - Coluna de partida.
         * @param {number} toRow - Linha de destino.
         * @param {number} toCol - Coluna de destino.
         * @param {string} [promotedToPiece] - Opcional: A peça para promover (ex: 'Q', 'n').
         */
        function makeMove(fromRow, fromCol, toRow, toCol, promotedToPiece = null) {
            const movedPieceChar = board[fromRow][fromCol];
            const capturedPieceChar = board[toRow][toCol];

            const fromSquareElement = chessboardElement.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
            const toSquareElement = chessboardElement.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
            const pieceElement = fromSquareElement.querySelector('.piece');

            if (!pieceElement) return; // Não deve acontecer se selectedPiece for válido

            // Se houver uma peça capturada, cria e anima o efeito de explosão E toca o som de captura
            if (capturedPieceChar) {
                const capturedPieceElement = toSquareElement.querySelector('.piece');
                if (capturedPieceElement) {
                    // Remove a peça capturada do DOM imediatamente para que a explosão apareça no seu lugar
                    capturedPieceElement.remove();

                    // Cria o elemento de explosão
                    const explosionElement = document.createElement('div');
                    explosionElement.classList.add('explosion');
                    // Posiciona o elemento de explosão sobre a casa de destino
                    explosionElement.style.top = `${toSquareElement.offsetTop}px`;
                    explosionElement.style.left = `${toSquareElement.offsetLeft}px`;
                    explosionElement.style.width = `${toSquareElement.offsetWidth}px`;
                    explosionElement.style.height = `${toSquareElement.offsetHeight}px`;
                    
                    // Adiciona o elemento de explosão ao contêiner do tabuleiro
                    chessboardElement.appendChild(explosionElement);

                    // Remove o elemento de explosão após a animação
                    explosionElement.addEventListener('animationend', () => {
                        explosionElement.remove();
                    });

                    playCaptureSound(); // Toca o som de captura
                }
            } else {
                // Se não houve captura, toca o som de movimento
                playMoveSound();
            }


            // Determina a rotação vertical da peça para que ela permaneça na vertical em relação ao jogador
            const targetPieceRotation = (gameMode === 'player' && currentPlayer === 'black') ? 'rotate(180deg)' : 'rotate(0deg)';

            // Calcula a translação necessária para a animação
            const fromRect = fromSquareElement.getBoundingClientRect();
            const toRect = toSquareElement.getBoundingClientRect();

            let offsetX = toRect.left - fromRect.left;
            let offsetY = toRect.top - fromRect.top;

            // Ajusta os offsets se o tabuleiro estiver invertido para o jogador preto (no modo dois jogadores)
            if (gameMode === 'player' && currentPlayer === 'black') {
                offsetX = -offsetX; // Inverte o eixo X
                offsetY = -offsetY; // Inverte o eixo Y
            }

            // Remove temporariamente a transição para evitar animação indesejada ao definir a posição inicial
            pieceElement.style.transition = 'none';

            // Define a transformação inicial da peça para a sua rotação vertical (sem translação ainda)
            pieceElement.style.transform = targetPieceRotation;

            // Força um reflow para aplicar a transformação inicial imediatamente
            void pieceElement.offsetWidth;

            // Adiciona novamente a transição para a animação de movimento
            pieceElement.style.transition = 'transform 0.3s ease-out';

            // Aplica a transformação combinada: translação primeiro, depois a rotação desejada
            pieceElement.style.transform = `translate(${offsetX}px, ${offsetY}px) ${targetPieceRotation}`;

            // Após a animação, atualiza o array do tabuleiro e move o elemento da peça para o novo quadrado
            setTimeout(() => {
                // Atualiza as flags de roque
                if (movedPieceChar === 'K') whiteKingMoved = true;
                if (movedPieceChar === 'k') blackKingMoved = true;
                if (movedPieceChar === 'R' && fromRow === 7 && fromCol === 0) whiteRookLeftMoved = true;
                if (movedPieceChar === 'R' && fromRow === 7 && fromCol === 7) whiteRookRightMoved = true;
                if (movedPieceChar === 'r' && fromRow === 0 && fromCol === 0) blackRookLeftMoved = true;
                if (movedPieceChar === 'r' && fromRow === 0 && fromCol === 7) blackRookRightMoved = true;

                // Atualiza o hash Zobrist para o movimento
                currentZobristHash ^= ZOBRIST_TABLE[movedPieceChar][fromRow][fromCol];
                if (capturedPieceChar) {
                    currentZobristHash ^= ZOBRIST_TABLE[capturedPieceChar][toRow][toCol]; // XOR da peça capturada
                }

                // Atualiza o estado interno do tabuleiro
                board[toRow][toCol] = movedPieceChar;
                board[fromRow][fromCol] = '';

                // Lida com a lógica de promoção
                let finalPieceChar = movedPieceChar;
                if (movedPieceChar.toLowerCase() === 'p' && ((isWhitePiece(movedPieceChar) && toRow === 0) || (isBlackPiece(movedPieceChar) && toRow === 7))) {
                    finalPieceChar = promotedToPiece || (isWhitePiece(movedPieceChar) ? 'Q' : 'q'); // Padrão para Rainha
                    // Atualiza o hash Zobrist para promoção
                    currentZobristHash ^= ZOBRIST_TABLE[movedPieceChar][toRow][toCol]; // XOR do peão
                    currentZobristHash ^= ZOBRIST_TABLE[finalPieceChar][toRow][toCol]; // XOR da nova peça promovida
                    board[toRow][toCol] = finalPieceChar; // Atualiza o tabuleiro com a peça promovida
                } else {
                    currentZobristHash ^= ZOBRIST_TABLE[movedPieceChar][toRow][toCol]; // XOR da peça movida (se não houver promoção)
                }

                // XOR do turno antigo e XOR do novo turno (apenas se não estiver esperando promoção humana)
                if (! (movedPieceChar.toLowerCase() === 'p' && ((isWhitePiece(movedPieceChar) && toRow === 0) || (isBlackPiece(movedPieceChar) && toRow === 7)) && !isThinking) ) {
                    currentZobristHash ^= ZOBRIST_TABLE.turn[currentPlayer];
                    const newPlayer = currentPlayer === 'white' ? 'black' : 'white';
                    currentZobristHash ^= ZOBRIST_TABLE.turn[newPlayer];
                }

                // Move o elemento da peça para o novo quadrado no DOM
                toSquareElement.appendChild(pieceElement);
                // Redefine a transformação da peça para apenas a sua rotação vertical
                pieceElement.style.transform = targetPieceRotation;
                pieceElement.style.transition = ''; // Reinicia a transição para o próximo movimento

                // Se foi uma promoção, atualiza o HTML da peça
                if (finalPieceChar !== movedPieceChar) {
                    pieceElement.innerHTML = PIECES[finalPieceChar];
                    pieceElement.className = ''; // Limpa as classes existentes
                    pieceElement.classList.add('piece', isWhitePiece(finalPieceChar) ? 'white-piece' : 'black-piece');
                    pieceElement.style.transform = targetPieceRotation; // Garante que a peça promovida esteja na vertical
                }

                // Limpa o quadrado antigo no DOM (garante que o quadrado antigo esteja vazio)
                fromSquareElement.innerHTML = '';

                // Continua o fluxo do jogo
                deselectPiece();
                // Verifica promoção de peão após fazer a jogada
                if (!(movedPieceChar.toLowerCase() === 'p' && ((isWhitePiece(movedPieceChar) && toRow === 0) || (isBlackPiece(movedPieceChar) && toRow === 7)))) {
                    switchPlayer();
                    saveCurrentState(); // Salva o estado após um movimento válido e troca de jogador
                } else if (!isThinking) { // Se for uma promoção e não for a IA, mostra o modal
                    promotionTarget = [toRow, toCol]; // Armazena a casa de destino para promoção
                    showPromotionModal(isWhitePiece(movedPieceChar));
                } else { // Se for uma promoção e for a IA, já lidou com isso
                    switchPlayer();
                    saveCurrentState();
                }

            }, 300); // Duração da animação (0.3s)
        }

        /**
         * Executa um movimento de roque com animação.
         * @param {number} kingStartRow - Linha da posição inicial do Rei.
         * @param {number} kingStartCol - Coluna da posição inicial do Rei.
         * @param {number} kingEndRow - Linha da posição final do Rei (casa de roque).
         * @param {number} rookOriginalCol - Coluna original da Torre envolvida no roque.
         */
        function makeCastlingMove(kingStartRow, kingStartCol, kingEndRow, rookOriginalCol) {
            const isWhite = isWhitePiece(board[kingStartRow][kingStartCol]);
            const kingPieceChar = board[kingStartRow][kingStartCol];
            const rookPieceChar = board[kingEndRow][rookOriginalCol];

            const kingStartSquare = chessboardElement.querySelector(`[data-row="${kingStartRow}"][data-col="${kingStartCol}"]`);
            const rookStartSquare = chessboardElement.querySelector(`[data-row="${kingEndRow}"][data-col="${rookOriginalCol}"]`);
            const kingPieceElement = kingStartSquare.querySelector('.piece');
            const rookPieceElement = rookStartSquare.querySelector('.piece');

            if (!kingPieceElement || !rookPieceElement) return;

            let kingFinalCol;
            let rookFinalCol;

            if (rookOriginalCol === 7) { // Roque do lado do rei
                kingFinalCol = kingStartCol + 2;
                rookFinalCol = kingStartCol + 1;
            } else { // Roque do lado da rainha
                kingFinalCol = kingStartCol - 2;
                rookFinalCol = kingStartCol - 1;
            }

            const kingEndSquare = chessboardElement.querySelector(`[data-row="${kingEndRow}"][data-col="${kingFinalCol}"]`);
            const rookEndSquare = chessboardElement.querySelector(`[data-row="${kingEndRow}"][data-col="${rookFinalCol}"]`);

            // Toca o som de movimento para o roque
            playMoveSound();

            // Determina a rotação vertical das peças para que elas permaneçam na vertical em relação ao jogador
            const targetPieceRotation = (gameMode === 'player' && currentPlayer === 'black') ? 'rotate(180deg)' : 'rotate(0deg)';

            // Calcula o deslocamento da animação do rei
            const kingFromRect = kingStartSquare.getBoundingClientRect();
            const kingToRect = kingEndSquare.getBoundingClientRect();
            let kingOffsetX = kingToRect.left - kingFromRect.left;
            let kingOffsetY = kingToRect.top - kingFromRect.top;

            // Calcula o deslocamento da animação da torre
            const rookFromRect = rookStartSquare.getBoundingClientRect();
            const rookToRect = rookEndSquare.getBoundingClientRect();
            let rookOffsetX = rookToRect.left - rookFromRect.left;
            let rookOffsetY = rookToRect.top - rookFromRect.top;

            // Ajusta os offsets se o tabuleiro estiver invertido para o jogador preto (no modo dois jogadores)
            if (gameMode === 'player' && currentPlayer === 'black') {
                kingOffsetX = -kingOffsetX;
                kingOffsetY = -kingOffsetY;
                rookOffsetX = -rookOffsetX;
                rookOffsetY = -rookOffsetY;
            }

            // Remove temporariamente a transição para rei e torre
            kingPieceElement.style.transition = 'none';
            rookPieceElement.style.transition = 'none';

            // Define as transformações iniciais para a rotação vertical
            kingPieceElement.style.transform = targetPieceRotation;
            rookPieceElement.style.transform = targetPieceRotation;

            // Força reflow
            void kingPieceElement.offsetWidth;
            void rookPieceElement.offsetWidth;

            // Adiciona novamente a transição para o movimento
            kingPieceElement.style.transition = 'transform 0.3s ease-out';
            rookPieceElement.style.transition = 'transform 0.3s ease-out';

            // Aplica as transformações combinadas para a animação
            kingPieceElement.style.transform = `translate(${kingOffsetX}px, ${kingOffsetY}px) ${targetPieceRotation}`;
            rookPieceElement.style.transform = `translate(${rookOffsetX}px, ${rookOffsetY}px) ${targetPieceRotation}`;

            setTimeout(() => {
                // Atualiza as flags de roque
                if (isWhite) {
                    whiteKingMoved = true;
                    if (rookOriginalCol === 0) whiteRookLeftMoved = true;
                    else whiteRookRightMoved = true;
                } else {
                    blackKingMoved = true;
                    if (rookOriginalCol === 0) blackRookLeftMoved = true;
                    else blackRookRightMoved = true;
                }

                // Atualiza o hash Zobrist para o roque
                currentZobristHash ^= ZOBRIST_TABLE[kingPieceChar][kingStartRow][kingStartCol];
                currentZobristHash ^= ZOBRIST_TABLE[kingPieceChar][kingEndRow][kingFinalCol];
                currentZobristHash ^= ZOBRIST_TABLE[rookPieceChar][kingEndRow][rookOriginalCol]; // Corrigido: Estava faltando o operador ^=
                currentZobristHash ^= ZOBRIST_TABLE[rookPieceChar][kingEndRow][rookFinalCol]; // Corrigido: Estava faltando o operador ^=
                currentZobristHash ^= ZOBRIST_TABLE.turn[currentPlayer];
                const newPlayer = currentPlayer === 'white' ? 'black' : 'white';
                currentZobristHash ^= ZOBRIST_TABLE.turn[newPlayer];

                // Atualiza o estado interno do tabuleiro
                board[kingEndRow][kingFinalCol] = kingPieceChar;
                board[kingStartRow][kingStartCol] = '';
                board[kingEndRow][rookFinalCol] = rookPieceChar;
                board[kingEndRow][rookOriginalCol] = '';

                // Move os elementos das peças no DOM
                kingEndSquare.appendChild(kingPieceElement);
                rookEndSquare.appendChild(rookPieceElement);

                // Limpa os quadrados antigos no DOM
                kingStartSquare.innerHTML = '';
                rookStartSquare.innerHTML = '';

                // Redefine as transformações para apenas a rotação vertical
                kingPieceElement.style.transform = targetPieceRotation;
                rookPieceElement.style.transform = targetPieceRotation;
                kingPieceElement.style.transition = ''; // Reinicia a transição
                rookPieceElement.style.transition = ''; // Reinicia a transição

                // Continua o fluxo do jogo
                deselectPiece();
                switchPlayer();
                saveCurrentState();
            }, 300); // Duração da animação
        }

        /**
         * Aplica a rotação do tabuleiro com base no jogador atual e no modo de jogo.
         * A rotação é instantânea, sem animação.
         * As peças são contra-rotacionadas para permanecerem na vertical.
         * @param {string} playerToRotateTo - O jogador para o qual o tabuleiro deve ser orientado ('white' ou 'black').
         */
        function applyBoardRotation(playerToRotateTo) {
            let boardRotation = 'rotate(0deg)';
            let pieceCounterRotation = 'rotate(0deg)';

            if (gameMode === 'player') { // Somente no modo de dois jogadores
                // No modo de dois jogadores, inverte o tabuleiro para o jogador preto
                if (playerToRotateTo === 'black') {
                    boardRotation = 'rotate(180deg)';
                    pieceCounterRotation = 'rotate(180deg)';
                }
            }
            // No modo de um jogador (computer), o tabuleiro e as peças sempre ficam em 0deg (perspectiva do branco)

            // Aplica a rotação do tabuleiro (instantânea)
            chessboardElement.style.transition = 'none'; // Garante que não haja transição
            chessboardElement.style.transform = boardRotation;
            void chessboardElement.offsetWidth; // Força reflow para aplicar a mudança imediatamente

            // Atualiza a rotação de todas as peças para que permaneçam na vertical (contra-rotação)
            const pieceElements = chessboardElement.querySelectorAll('.piece');
            pieceElements.forEach(pieceEl => {
                pieceEl.style.transition = 'none'; // Garante que não haja transição
                pieceEl.style.transform = pieceCounterRotation;
                void pieceEl.offsetWidth; // Força reflow
            });
        }

        /**
         * Troca o jogador atual.
         */
        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            applyBoardRotation(currentPlayer); // Aplica a rotação do tabuleiro (agora instantânea)
            updateStatus();

            // Verifica xeque-mate/empate por afogamento aqui
            if (isCheckmate(currentPlayer)) {
                gameOver = true;
                statusElement.textContent = `Xeque-mate! ${currentPlayer === 'white' ? 'Pretas' : 'Brancas'} Venceram!`;
                playCheckmateSound(); // Toca o som de xeque-mate
            } else if (isStalemate(currentPlayer)) {
                gameOver = true;
                statusElement.textContent = `Empate por Afogamento!`;
            } else if (isKingInCheck(currentPlayer)) { // Verifica se o rei do jogador atual está em xeque
                playCheckSound(); // Toca o som de xeque
            }

            // Se o jogo não acabou e for a vez da IA, a IA faz a jogada
            if (!gameOver && gameMode === 'computer' && currentPlayer === 'black') {
                isThinking = true;
                statusElement.textContent = "Computador pensando...";
                updateHistoryButtons(); // Desabilita botões enquanto a IA pensa
                setTimeout(makeComputerMove, 500); // Pequeno atraso para melhor UX
            } else {
                isThinking = false;
                updateHistoryButtons(); // Reabilita botões
            }
        }

        /**
         * Atualiza a mensagem de status exibida ao usuário.
         */
        function updateStatus() {
            if (!gameOver) {
                statusElement.textContent = `Vez das ${currentPlayer === 'white' ? 'Brancas' : 'Pretas'}`;
            } else {
                // Se o jogo acabou, a mensagem de status já está definida por xeque-mate/empate
                // Não há necessidade de alterá-la aqui, a menos que estejamos visualizando o estado anterior.
                if (historyPointer < gameHistory.length - 1) {
                     statusElement.textContent = `Vez das ${gameHistory[historyPointer].currentPlayer === 'white' ? 'Brancas' : 'Pretas'}`;
                }
            }
        }

        /**
         * Verifica se um movimento é válido e legal para uma dada peça.
         * Esta função também verifica se o movimento coloca ou deixa o rei do jogador atual em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} fromRow - Linha de partida.
         * @param {number} fromCol - Coluna de partida.
         * @param {number} toRow - Linuna de destino.
         * @param {number} toCol - Coluna de destino.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o movimento for válido e legal.
         */
        function isValidMove(piece, fromRow, fromCol, toRow, toCol, currentBoard = board) {
            // Verificações básicas de limite
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;

            const targetPiece = currentBoard[toRow][toCol];
            const isWhitePieceFn = (p) => p === p.toUpperCase();
            const isBlackPieceFn = (p) => p === p.toLowerCase();
            const isCurrentPlayerPieceFn = (p) => (currentPlayer === 'white' && isWhitePieceFn(p)) || (currentPlayer === 'black' && isBlackPieceFn(p));

            // Não pode capturar sua própria peça
            if (targetPiece && isCurrentPlayerPieceFn(targetPiece)) {
                return false;
            }

            // Obtém os movimentos pseudo-legais para a peça (movimentos baseados no padrão da peça, ignorando a segurança do rei por enquanto)
            const pseudoLegalMoves = getPossibleMoves(piece, fromRow, fromCol, currentBoard);
            const isPseudoLegal = pseudoLegalMoves.some(([r, c]) => r === toRow && c === toCol);

            if (!isPseudoLegal) {
                return false; // Não é um padrão de movimento válido para esta peça
            }

            // --- Crucial: Simula o movimento e verifica a segurança do rei ---
            const originalPiece = currentBoard[fromRow][fromCol];
            const pieceAtTarget = currentBoard[toRow][toCol]; // Armazena o que está no destino

            // Temporariamente faz o movimento no tabuleiro
            currentBoard[toRow][toCol] = originalPiece;
            currentBoard[fromRow][fromCol] = '';

            // Lida com a promoção de peão na simulação para verificação de segurança do rei
            if (originalPiece.toLowerCase() === 'p') {
                if ((isWhitePiece(originalPiece) && toRow === 0) || (isBlackPiece(originalPiece) && toRow === 7)) {
                    // Promove para Rainha para fins de verificação de segurança do rei
                    currentBoard[toRow][toCol] = isWhitePiece(originalPiece) ? 'Q' : 'q';
                }
            }


            // Verifica se o rei *do jogador atual* está em xeque após este movimento simulado
            const kingInCheckAfterMove = isKingInCheck(currentPlayer, currentBoard);

            // Reverte o movimento
            currentBoard[fromRow][fromCol] = originalPiece;
            currentBoard[toRow][toCol] = pieceAtTarget;

            if (kingInCheckAfterMove) {
                return false; // O movimento é ilegal porque deixa o rei do jogador atual em xeque
            }

            return true; // O movimento é válido e legal
        }

        /**
         * Retorna um array de movimentos pseudo-legais para uma dada peça em uma posição específica.
         * Movimentos pseudo-legais são baseados no padrão de movimento da peça e nas regras de captura,
         * mas NÃO consideram se o movimento coloca ou deixa o rei do próprio jogador em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} row - A linha atual da peça.
         * @param {number} col - A coluna atual da peça.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {Array<Array<number>>} - Um array de pares [linha, coluna] representando movimentos pseudo-legais.
         */
        function getPossibleMoves(piece, row, col, currentBoard = board) {
            const moves = [];
            const isWhite = isWhitePiece(piece);
            const pieceType = piece.toLowerCase();

            const addMove = (r, c) => {
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = currentBoard[r][c];
                    // Se a casa de destino estiver vazia ou contiver uma peça do oponente
                    if (!targetPiece || (isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece))) {
                        moves.push([r, c]);
                    }
                }
            };

            const checkPath = (dr, dc) => {
                for (let i = 1; i < 8; i++) {
                    const r = row + i * dr;
                    const c = col + i * dc;
                    if (r < 0 || r > 7 || c < 0 || c > 7) break;
                    const targetPiece = currentBoard[r][c];
                    if (targetPiece) {
                        if ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece))) {
                            addMove(r, c); // Pode capturar
                        }
                        break; // Caminho bloqueado por qualquer peça
                    }
                    addMove(r, c);
                }
            };

            switch (pieceType) {
                case 'p': // Peão
                    const direction = isWhite ? -1 : 1;
                    const startRow = isWhite ? 6 : 1;

                    // Um único movimento para frente
                    if (currentBoard[row + direction] && !currentBoard[row + direction][col]) {
                        addMove(row + direction, col);
                        // Movimento duplo inicial para frente
                        if (row === startRow && currentBoard[row + 2 * direction] && !currentBoard[row + 2 * direction][col]) {
                            addMove(row + 2 * direction, col);
                        }
                    }

                    // Capturas (movimentos diagonais apenas se capturando)
                    // Captura à esquerda
                    if (col > 0) {
                        const targetPiece = currentBoard[row + direction]?.[col - 1];
                        if (targetPiece && ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece)))) {
                            addMove(row + direction, col - 1);
                        }
                    }
                    // Captura à direita
                    if (col < 7) {
                        const targetPiece = currentBoard[row + direction]?.[col + 1];
                        if (targetPiece && ((isWhite && isBlackPiece(targetPiece)) || (!isWhite && isWhitePiece(targetPiece)))) {
                            addMove(row + direction, col + 1);
                        }
                    }
                    break;
                case 'r': // Torre
                    checkPath(1, 0); checkPath(-1, 0); // Vertical
                    checkPath(0, 1); checkPath(0, -1); // Horizontal
                    break;
                case 'n': // Cavalo
                    const knightMoves = [
                        [2, 1], [2, -1], [-2, 1], [-2, -1],
                        [1, 2], [1, -2], [-1, 2], [-1, -2]
                    ];
                    knightMoves.forEach(([dr, dc]) => addMove(row + dr, col + dc));
                    break;
                case 'b': // Bispo
                    checkPath(1, 1); checkPath(1, -1); // Diagonal
                    checkPath(-1, 1); checkPath(-1, -1);
                    break;
                case 'q': // Rainha
                    checkPath(1, 0); checkPath(-1, 0); // Vertical
                    checkPath(0, 1); checkPath(0, -1); // Horizontal
                    checkPath(1, 1); checkPath(1, -1); // Diagonal
                    checkPath(-1, 1); checkPath(-1, -1);
                    break;
                case 'k': // Rei
                    const kingMoves = [
                        [1, 0], [-1, 0], [0, 1], [0, -1],
                        [1, 1], [1, -1], [-1, 1], [-1, -1]
                    ];
                    kingMoves.forEach(([dr, dc]) => addMove(row + dr, col + dc));

                    // Adiciona o roque como movimentos pseudo-legais (casas de destino do rei)
                    // Roque do lado do rei
                    if (isWhite) {
                        if (!whiteKingMoved && !whiteRookRightMoved &&
                            currentBoard[7][5] === '' && currentBoard[7][6] === '') {
                            moves.push([7, 6]); // Casa de destino para roque do lado do rei
                        }
                        // Roque do lado da rainha
                        if (!whiteKingMoved && !whiteRookLeftMoved &&
                            currentBoard[7][1] === '' && currentBoard[7][2] === '' && currentBoard[7][3] === '') {
                            moves.push([7, 2]); // Casa de destino para roque do lado da rainha
                        }
                    } else { // Rei Preto
                        if (!blackKingMoved && !blackRookRightMoved &&
                            currentBoard[0][5] === '' && currentBoard[0][6] === '') {
                            moves.push([0, 6]); // Casa de destino para roque do lado do rei
                        }
                        if (!blackKingMoved && !blackRookLeftMoved &&
                            currentBoard[0][1] === '' && currentBoard[0][2] === '' && currentBoard[0][3] === '') {
                            moves.push([0, 2]); // Casa de destino para roque do lado da rainha
                        }
                    }
                    break;
            }
            return moves;
        }

        /**
         * Retorna um array de movimentos verdadeiramente legais para uma dada peça em uma posição específica.
         * Movimentos legais são movimentos pseudo-legais que NÃO colocam ou deixam o rei do próprio jogador em xeque.
         * @param {string} piece - O caractere da peça.
         * @param {number} row - A linha atual da peça.
         * @param {number} col - A coluna atual da peça.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {Array<Array<number>>} - Um array de pares [linha, coluna] representando movimentos legais.
         */
        function getLegalMoves(piece, row, col, currentBoard = board) {
            const pseudoLegalMoves = getPossibleMoves(piece, row, col, currentBoard); // Obtém movimentos baseados no padrão da peça
            const legalMoves = [];
            const originalCurrentPlayer = currentPlayer; // Armazena o jogador original

            pseudoLegalMoves.forEach(([toR, toC]) => {
                // Para movimentos de roque, a casa de destino é onde o Rei aterrissa.
                // Precisamos verificar as condições de roque novamente aqui, especialmente as casas atacadas.
                if (piece.toLowerCase() === 'k' && (Math.abs(toC - col) === 2)) {
                    // Este é um pseudo-movimento de roque. Determina a coluna original da torre.
                    const rookOriginalCol = (toC > col) ? 7 : 0;
                    // Passa currentBoard para isValidCastling
                    if (isValidCastling(row, col, toR, rookOriginalCol, currentBoard)) {
                        legalMoves.push([toR, toC]);
                    }
                } else {
                    // Para movimentos regulares, usa isValidMove
                    // Define temporariamente o jogador atual para aquele cujos movimentos estamos testando
                    // Isso é crucial para isValidMove verificar corretamente a segurança do rei para este jogador.
                    currentPlayer = isWhitePiece(piece) ? 'white' : 'black';

                    if (isValidMove(piece, row, col, toR, toC, currentBoard)) {
                        legalMoves.push([toR, toC]);
                    }
                }
            });

            // Reverte para o jogador atual original
            currentPlayer = originalCurrentPlayer;
            return legalMoves;
        }

        /**
         * Verifica se um movimento de roque é válido.
         * Esta função verifica todas as condições para o roque, incluindo histórico de movimento do rei e da torre,
         * caminho livre e segurança do rei (não em xeque, não passando por casas atacadas, não aterrissando em casa atacada).
         * @param {number} kingStartRow - A linha da posição inicial do Rei.
         * @param {number} kingStartCol - A coluna da posição inicial do Rei.
         * @param {number} kingEndRow - A linha da posição final do Rei (casa de roque).
         * @param {number} rookOriginalCol - A coluna original da Torre envolvida no roque.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o movimento de roque for válido.
         */
        function isValidCastling(kingStartRow, kingStartCol, kingEndRow, rookOriginalCol, currentBoard = board) {
            const kingPiece = currentBoard[kingStartRow][kingStartCol];
            const rookPiece = currentBoard[kingEndRow][rookOriginalCol]; // A Torre está na mesma linha que o rei

            // 1. Verifica se as peças são Rei e Torre
            if (kingPiece.toLowerCase() !== 'k' || !rookPiece || rookPiece.toLowerCase() !== 'r') return false;

            // 2. Verifica se o Rei e a Torre são da mesma cor e pertencem ao jogador atual
            if (!isCurrentPlayerPiece(kingPiece) || !isCurrentPlayerPiece(rookPiece)) return false;
            if (isWhitePiece(kingPiece) !== isWhitePiece(rookPiece)) return false;

            const isWhite = isWhitePiece(kingPiece);

            // 3. Verifica se o Rei e a Torre se moveram (usa flags globais para o jogo real, não tabuleiro simulado)
            // Nota: Para simulação de minimax, essas flags não são passadas, então esta verificação dependerá do estado global.
            // Uma IA mais robusta passaria essas flags como parte do estado simulado.
            if (isWhite) {
                if (whiteKingMoved) return false;
                if (rookOriginalCol === 0 && whiteRookLeftMoved) return false;
                if (rookOriginalCol === 7 && whiteRookRightMoved) return false;
            } else {
                if (blackKingMoved) return false;
                if (rookOriginalCol === 0 && blackRookLeftMoved) return false;
                if (rookOriginalCol === 7 && blackRookRightMoved) return false;
            }

            // 4. Verifica se o caminho entre o Rei e a Torre está livre
            if (rookOriginalCol === 7) { // Roque do lado do rei
                if (currentBoard[kingStartRow][5] !== '' || currentBoard[kingStartRow][6] !== '') return false;
            } else if (rookOriginalCol === 0) { // Roque do lado da rainha
                if (currentBoard[kingStartRow][1] !== '' || currentBoard[kingStartRow][2] !== '' || currentBoard[kingStartRow][3] !== '') return false;
            } else {
                return false; // Torre não está em uma posição de roque válida
            }

            // 5. Verifica se o Rei está atualmente em xeque
            if (isKingInCheck(isWhite ? 'white' : 'black', currentBoard)) return false;

            // 6. Verifica se o Rei passa por ou aterrissa em uma casa atacada
            const opponentColor = isWhite ? 'black' : 'white';
            if (rookOriginalCol === 7) { // Roque do lado do rei
                if (isSquareAttacked(kingStartRow, kingStartCol + 1, opponentColor, currentBoard) || // Casa por onde o Rei passa
                    isSquareAttacked(kingStartRow, kingStartCol + 2, opponentColor, currentBoard)) { // Casa onde o Rei aterrissa
                    return false;
                }
            } else if (rookOriginalCol === 0) { // Roque do lado da rainha
                if (isSquareAttacked(kingStartRow, kingStartCol - 1, opponentColor, currentBoard) || // Casa por onde o Rei passa
                    isSquareAttacked(kingStartRow, kingStartCol - 2, opponentColor, currentBoard)) { // Casa onde o Rei aterrissa
                    return false;
                }
            }

            return true;
        }

        /**
         * Encontra a posição do Rei para um dado jogador.
         * @param {string} playerColor - 'white' ou 'black'.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {Array<number>|null} - [linha, coluna] do Rei, ou null se não encontrado.
         */
        function findKing(playerColor, currentBoard = board) {
            const kingPiece = playerColor === 'white' ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === kingPiece) {
                        return [r, c];
                    }
                }
            }
            return null; // Não deveria acontecer em um jogo válido
        }

        /**
         * Verifica se o rei dado está atualmente em xeque.
         * @param {string} kingColor - A cor do rei a ser verificada ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o rei estiver em xeque.
         */
        function isKingInCheck(kingColor, currentBoard = board) {
            const kingPos = findKing(kingColor, currentBoard);
            if (!kingPos) return false; // Rei não encontrado (ex: em um estado de tabuleiro simulado onde foi capturado)

            const [kingRow, kingCol] = kingPos;
            const opponentColor = kingColor === 'white' ? 'black' : 'white';

            return isSquareAttacked(kingRow, kingCol, opponentColor, currentBoard);
        }

        /**
         * Verifica se uma casa específica é atacada por uma peça de uma dada cor.
         * Esta função é crucial para a segurança do rei e validação de roque.
         * @param {number} row - A linha da casa a ser verificada.
         * @param {number} col - A coluna da casa a ser verificada.
         * @param {string} attackerColor - A cor das peças que podem estar atacando.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se a casa for atacada por um atacante da cor especificada.
         */
        function isSquareAttacked(row, col, attackerColor, currentBoard = board) {
            const originalCurrentPlayer = currentPlayer; // Armazena o jogador original
            currentPlayer = attackerColor; // Define temporariamente o jogador atual para o atacante para usar getPossibleMoves corretamente

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    // Verifica se a peça pertence ao attackerColor
                    if (piece && ((attackerColor === 'white' && isWhitePiece(piece)) || (attackerColor === 'black' && isBlackPiece(piece)))) {
                        // Obtém os movimentos pseudo-legais que esta peça atacante *poderia* fazer
                        const attackerPseudoLegalMoves = getPossibleMoves(piece, r, c, currentBoard);

                        // Verifica se algum dos movimentos pseudo-legais do atacante visa a casa especificada
                        if (attackerPseudoLegalMoves.some(([moveR, moveC]) => moveR === row && moveC === col)) {
                            currentPlayer = originalCurrentPlayer; // Reverte antes de retornar
                            return true; // A peça atacante pode atacar a casa
                        }
                    }
                }
            }
            currentPlayer = originalCurrentPlayer; // Reverte se nenhum ataque for encontrado
            return false;
        }

        /**
         * Verifica se o jogador atual está em xeque-mate.
         * Itera por todos os movimentos legais possíveis para o jogador atual.
         * @param {string} playerColor - A cor do jogador a ser verificada ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o jogador estiver em xeque-mate.
         */
        function isCheckmate(playerColor, currentBoard = board) {
            if (!isKingInCheck(playerColor, currentBoard)) {
                return false; // Não está em xeque, então não pode ser xeque-mate
            }

            // Se estiver em xeque, verifica se há algum movimento legal para sair do xeque
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        // Obtém todos os movimentos legais para esta peça (que já considera a segurança do rei)
                        const legalMoves = getLegalMoves(piece, r, c, currentBoard);
                        if (legalMoves.length > 0) {
                            return false; // Encontrou pelo menos um movimento legal, então não é xeque-mate
                        }
                    }
                }
            }
            return true; // Nenhum movimento legal encontrado para nenhuma peça, e o rei está em xeque, então é xeque-mate
        }

        /**
         * Verifica se o jogador atual está em empate por afogamento (empate por falta de movimentos legais).
         * @param {string} playerColor - A cor do jogador a ser verificada ('white' ou 'black').
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro para verificar.
         * @returns {boolean} - True se o jogador estiver em empate por afogamento.
         */
        function isStalemate(playerColor, currentBoard = board) {
            if (isKingInCheck(playerColor, currentBoard)) {
                return false; // Se estiver em xeque, não é empate por afogamento (é xeque-mate se não houver movimentos legais)
            }

            // Verifica se o jogador atual tem algum movimento legal
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        const legalMoves = getLegalMoves(piece, r, c, currentBoard);
                        if (legalMoves.length > 0) {
                            return false; // Encontrou pelo menos um movimento legal, então não é empate por afogamento
                        }
                    }
                }
            }
            return true; // Nenhum movimento legal encontrado para nenhuma peça, e o rei NÃO está em xeque, então é empate por afogamento
        }

        /**
         * Avalia o estado atual do tabuleiro da perspectiva do jogador maximizador (IA, que é o preto).
         * Uma pontuação positiva favorece o preto, uma pontuação negativa favorece o branco.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro a ser avaliado.
         * @returns {number} - A pontuação do tabuleiro.
         */
        function evaluateBoard(currentBoard) {
            let score = 0;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece) {
                        // Adiciona o valor base da peça (positivo para preto, negativo para branco)
                        score += PIECE_VALUES[piece] || 0;

                        // Adiciona a pontuação posicional
                        const pieceType = piece.toLowerCase();
                        const isWhite = isWhitePiece(piece);
                        let positionalValue = 0;

                        // As tabelas de posição são da perspectiva do branco.
                        // Para peças pretas, precisamos inverter o índice da linha para obter o valor posicional correto.
                        const tableRow = isWhite ? r : 7 - r;
                        const tableCol = c;

                        switch (pieceType) {
                            case 'p':
                                positionalValue = PAWN_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'n':
                                positionalValue = KNIGHT_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'b':
                                positionalValue = BISHOP_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'r':
                                positionalValue = ROOK_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'q':
                                positionalValue = QUEEN_POSITION_TABLE[tableRow][tableCol];
                                break;
                            case 'k':
                                // Determina se é o final do jogo para usar a tabela de rei apropriada
                                // Heurística simples: se o total de peças for baixo, é final do jogo
                                let totalNonKingPieces = 0;
                                for (let i = 0; i < 8; i++) {
                                    for (let j = 0; j < 8; j++) {
                                        const p = currentBoard[i][j];
                                        if (p && p.toLowerCase() !== 'k') {
                                            totalNonKingPieces++;
                                        }
                                    }
                                }
                                if (totalNonKingPieces < 8) { // Limiar arbitrário para o final do jogo
                                    positionalValue = KING_POSITION_TABLE_END_GAME[tableRow][tableCol];
                                } else {
                                    positionalValue = KING_POSITION_TABLE_MIDDLE_GAME[tableRow][tableCol];
                                }
                                break;
                        }
                        // Se for uma peça branca, seu valor posicional é subtraído da pontuação do preto.
                        // Se for uma peça preta, seu valor posicional é adicionado à pontuação do preto.
                        score += (isWhite ? -positionalValue : positionalValue);
                    }
                }
            }

            // Adiciona bônus para xeque-mate/empate por afogamento
            if (isCheckmate('white', currentBoard)) {
                score += 100000000; // Grande bônus para o preto dar xeque-mate no branco
            } else if (isCheckmate('black', currentBoard)) {
                score -= 100000000; // Grande penalidade para o preto levar xeque-mate
            } else if (isStalemate('white', currentBoard) || isStalemate('black', currentBoard)) {
                score += 0; // Empate por afogamento é um empate, sem mudança na pontuação
            }

            // Adiciona um bônus por colocar o oponente em xeque
            if (isKingInCheck('white', currentBoard)) { // Se o rei branco estiver em xeque
                score += 5000; // Bônus significativo para a IA (preto)
            }
            // Adiciona uma penalidade para o preto estar em xeque
            if (isKingInCheck('black', currentBoard)) { // Se o rei preto estiver em xeque
                score -= 5000; // Penalidade significativa para a IA (preto)
            }

            return score;
        }

        /**
         * Decide a melhor peça para promoção de peão da IA usando avaliação.
         * @param {Array<Array<string>>} currentBoard - O estado do tabuleiro antes da promoção.
         * @param {number} row - A linha onde o peão está promovendo.
         * @param {number} col - A coluna onde o peão está promovendo.
         * @param {boolean} isWhitePawn - True se o peão sendo promovido for branco.
         * @returns {string} O caractere da melhor peça para promover.
         */
        function decidePromotionPieceForAI(currentBoard, row, col, isWhitePawn) {
            const possiblePromotions = ['Q', 'R', 'B', 'N'];
            let bestPromotedPiece = isWhitePawn ? 'Q' : 'q'; // Padrão para Rainha
            let bestEvaluation = isWhitePawn ? Infinity : -Infinity; // Branco minimiza, Preto maximiza

            for (const pieceType of possiblePromotions) {
                const promotedPieceChar = isWhitePawn ? pieceType : pieceType.toLowerCase();
                const tempBoard = JSON.parse(JSON.stringify(currentBoard)); // Cria uma cópia

                // Promove temporariamente o peão no tabuleiro copiado
                tempBoard[row][col] = promotedPieceChar;

                const evaluation = evaluateBoard(tempBoard);

                if (isWhitePawn) { // IA Branca (jogador minimizador, mas nosso IA é preto, então este ramo não será usado)
                    if (evaluation < bestEvaluation) {
                        bestEvaluation = evaluation;
                        bestPromotedPiece = promotedPieceChar;
                    }
                } else { // IA Preta (jogador maximizador)
                    if (evaluation > bestEvaluation) {
                        bestEvaluation = evaluation;
                        bestPromotedPiece = promotedPieceChar;
                    }
                }
            }
            return bestPromotedPiece;
        }

        /**
         * Realiza uma busca de quiescência para avaliar posições ruidosas.
         * @param {Array<Array<string>>} currentBoard - O estado atual do tabuleiro.
         * @param {number} depth - A profundidade atual da busca de quiescência.
         * @param {boolean} isMaximizingPlayer - True se for o turno do jogador maximizador (IA, preto).
         * @param {number} alpha - A melhor pontuação que o jogador maximizador pode garantir até agora.
         * @param {number} beta - A melhor pontuação que o jogador minimizador pode garantir até agora.
         * @param {object} castlingFlags - Objeto com as flags de roque atuais.
         * @returns {number} - A melhor pontuação encontrada para a posição ruidosa atual.
         */
        function quiescenceSearch(currentBoard, depth, isMaximizingPlayer, alpha, beta, castlingFlags) {
            // Avalia o estado "quieto" atual (nenhum movimento tático imediato considerado ainda)
            let evaluation = evaluateBoard(currentBoard);

            if (isMaximizingPlayer) {
                alpha = Math.max(alpha, evaluation);
            } else {
                beta = Math.min(beta, evaluation);
            }

            if (alpha >= beta) {
                return evaluation; // Corte Alpha-beta
            }

            // Considera apenas movimentos de captura na busca de quiescência
            const movesToConsider = [];
            const playerColor = isMaximizingPlayer ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                        const pseudoLegalMoves = getPossibleMoves(piece, r, c, currentBoard);
                        pseudoLegalMoves.forEach(([toR, toC]) => {
                            const targetPiece = currentBoard[toR][toC];
                            // Adiciona apenas se for uma captura
                            if (targetPiece && ((isWhitePiece(piece) && isBlackPiece(targetPiece)) || (isBlackPiece(piece) && isWhitePiece(targetPiece)))) {
                                // Verifica se o movimento é legal (não coloca o próprio rei em xeque)
                                const originalCurrentPlayer = currentPlayer;
                                currentPlayer = playerColor; // Define temporariamente para o jogador atual para isValidMove
                                if (isValidMove(piece, r, c, toR, toC, currentBoard)) {
                                    movesToConsider.push({
                                        from: [r, c],
                                        to: [toR, toC],
                                        piece: piece,
                                        capturedPiece: targetPiece,
                                        capturedPieceValue: Math.abs(PIECE_VALUES[targetPiece])
                                    });
                                }
                                currentPlayer = originalCurrentPlayer; // Reverte
                            }
                        });
                    }
                }
            }

            // Classifica as capturas por valor (captura mais valiosa primeiro) para melhor poda
            movesToConsider.sort((a, b) => b.capturedPieceValue - a.capturedPieceValue);

            if (isMaximizingPlayer) {
                let maxEval = evaluation; // Começa com a avaliação estática da posição atual
                for (const move of movesToConsider) {
                    const { from: [fromR, fromC], to: [toR, toC], piece } = move;

                    const newBoard = JSON.parse(JSON.stringify(currentBoard));
                    const originalPiece = newBoard[fromR][fromC];
                    const capturedPiece = newBoard[toR][toC];

                    newBoard[toR][toC] = originalPiece;
                    newBoard[fromR][fromC] = '';

                    // Promoção de Peão no tabuleiro simulado (IA sempre promove para Rainha)
                    let promotedPiece = originalPiece;
                    if (originalPiece.toLowerCase() === 'p') {
                        if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                            promotedPiece = isWhitePiece(originalPiece) ? 'Q' : 'q'; // Ainda padrão para Rainha para simplificação na busca de quiescência
                            newBoard[toR][toC] = promotedPiece; // Atualiza a peça no novo tabuleiro
                        }
                    }

                    const newCastlingFlags = { ...castlingFlags }; // Passa flags atualizadas
                    if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                    if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 0) newCastlingFlags.whiteRookLeftMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 7) newCastlingFlags.whiteRookRightMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 0) newCastlingFlags.blackRookLeftMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 7) newCastlingFlags.blackRookRightMoved = true;

                    const evalResult = quiescenceSearch(newBoard, depth - 1, false, alpha, beta, newCastlingFlags);
                    maxEval = Math.max(maxEval, evalResult);
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) {
                        break;
                    }
                }
                return maxEval;
            } else { // Jogador minimizador
                let minEval = evaluation; // Começa com a avaliação estática
                for (const move of movesToConsider) {
                    const { from: [fromR, fromC], to: [toR, toC], piece } = move;

                    const newBoard = JSON.parse(JSON.stringify(currentBoard));
                    const originalPiece = newBoard[fromR][fromC];
                    const capturedPiece = newBoard[toR][toC];

                    newBoard[toR][toC] = originalPiece;
                    newBoard[fromR][fromC] = '';

                    // Promoção de Peão no tabuleiro simulado (IA sempre promove para Rainha)
                    let promotedPiece = originalPiece;
                    if (originalPiece.toLowerCase() === 'p') {
                        if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                            promotedPiece = isWhitePiece(originalPiece) ? 'Q' : 'q'; // Ainda padrão para Rainha para simplificação na busca de quiescência
                            newBoard[toR][toC] = promotedPiece; // Atualiza a peça no novo tabuleiro
                        }
                    }

                    const newCastlingFlags = { ...castlingFlags }; // Passa flags atualizadas
                    if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                    if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 0) newCastlingFlags.whiteRookLeftMoved = true;
                    if (originalPiece === 'R' && fromR === 7 && fromC === 7) newCastlingFlags.whiteRookRightMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 0) newCastlingFlags.blackRookLeftMoved = true;
                    if (originalPiece === 'r' && fromR === 0 && fromC === 7) newCastlingFlags.blackRookRightMoved = true;

                    const evalResult = quiescenceSearch(newBoard, depth - 1, true, alpha, beta, newCastlingFlags);
                    minEval = Math.min(minEval, evalResult);
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) {
                        break;
                    }
                }
                return minEval;
            }
        }


        /**
         * Algoritmo Minimax com Poda Alpha-Beta para encontrar o melhor movimento.
         * @param {Array<Array<string>>} currentBoard - O estado atual do tabuleiro.
         * @param {number} depth - A profundidade atual da busca.
         * @param {boolean} isMaximizingPlayer - True se for o turno do jogador maximizador (IA, preto).
         * @param {number} alpha - A melhor pontuação que o jogador maximizador pode garantir até agora.
         * @param {number} beta - A melhor pontuação que o jogador minimizador pode garantir até agora.
         * @param {object} castlingFlags - Objeto com as flags de roque atuais (whiteKingMoved, etc.).
         * @returns {number} - A melhor pontuação encontrada para o estado atual do tabuleiro.
         */
        function minimax(currentBoard, depth, isMaximizingPlayer, alpha, beta, castlingFlags) {
            // Calcula o hash para o estado atual do tabuleiro
            const boardHash = calculateBoardHash(currentBoard, isMaximizingPlayer ? 'black' : 'white', castlingFlags);

            // Verifica a tabela de transposição
            if (transpositionTable.has(boardHash)) {
                const entry = transpositionTable.get(boardHash);
                if (entry.depth >= depth) { // Se a avaliação armazenada for de uma busca mais profunda ou igual
                    return entry.evaluation;
                }
            }

            // Caso base: se a profundidade for 0, chama a busca de quiescência
            if (depth === 0) {
                const evaluation = quiescenceSearch(currentBoard, 3, isMaximizingPlayer, alpha, beta, castlingFlags); // Profundidade da busca de quiescência 3
                transpositionTable.set(boardHash, { evaluation, depth });
                return evaluation;
            }

            // Verifica estados de fim de jogo
            if (isCheckmate('white', currentBoard) || isCheckmate('black', currentBoard) || isStalemate('white', currentBoard) || isStalemate('black', currentBoard)) {
                const evaluation = evaluateBoard(currentBoard); // Avalia o estado final do jogo
                transpositionTable.set(boardHash, { evaluation, depth });
                return evaluation;
            }


            if (isMaximizingPlayer) { // Turno da IA (preto) - maximiza a pontuação
                let maxEval = -Infinity;
                const playerColor = 'black';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && isBlackPiece(piece)) {
                            const moves = getLegalMoves(piece, r, c, currentBoard);
                            // Classifica os movimentos para eficiência da poda Alpha-Beta dentro do minimax
                            moves.sort((a, b) => {
                                const targetPieceA = currentBoard[a[0]][a[1]]; // Peça no destino para o movimento A
                                const targetPieceB = currentBoard[b[0]][b[1]]; // Peça no destino para o movimento B
                                const valueA = targetPieceA ? Math.abs(PIECE_VALUES[targetPieceA]) : 0;
                                const valueB = targetPieceB ? Math.abs(PIECE_VALUES[targetPieceB]) : 0;
                                return valueB - valueA; // Prioriza capturas de peças de maior valor
                            });

                            for (const [toR, toC] of moves) {
                                // Simula o movimento
                                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                                const originalPiece = newBoard[r][c];
                                const capturedPiece = newBoard[toR][toC];

                                newBoard[toR][toC] = originalPiece;
                                newBoard[r][c] = '';

                                // Promoção de Peão no tabuleiro simulado
                                let simulatedMovedPiece = originalPiece;
                                if (originalPiece.toLowerCase() === 'p') {
                                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                                    }
                                }


                                // Simula a atualização das flags de roque para a chamada recursiva
                                const newCastlingFlags = { ...castlingFlags };
                                if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                                if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 0) newCastlingFlags.whiteRookLeftMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 7) newCastlingFlags.whiteRookRightMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 0) newCastlingFlags.blackRookLeftMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 7) newCastlingFlags.blackRookRightMoved = true;

                                // Lida com o movimento simulado da torre no roque
                                if (piece.toLowerCase() === 'k' && Math.abs(toC - c) === 2) {
                                    let rookOriginalCol;
                                    let rookFinalCol;
                                    if (toC > c) { // Roque do lado do rei
                                        rookOriginalCol = 7;
                                        rookFinalCol = c + 1;
                                    } else { // Roque do lado da rainha
                                        rookOriginalCol = 0;
                                        rookFinalCol = c - 1;
                                    }
                                    const rookPiece = newBoard[r][rookOriginalCol];
                                    newBoard[r][rookFinalCol] = rookPiece;
                                    newBoard[r][rookOriginalCol] = '';
                                }

                                const evaluation = minimax(newBoard, depth - 1, false, alpha, beta, newCastlingFlags);
                                maxEval = Math.max(maxEval, evaluation);
                                alpha = Math.max(alpha, maxEval);

                                if (beta <= alpha) { // Poda Alpha-Beta
                                    break;
                                }
                            }
                        }
                    }
                }
                transpositionTable.set(boardHash, { evaluation: maxEval, depth }); // Armazena a avaliação
                return maxEval;
            } else { // Turno do oponente (branco) - minimiza a pontuação
                let minEval = Infinity;
                const playerColor = 'white';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && isWhitePiece(piece)) {
                            const moves = getLegalMoves(piece, r, c, currentBoard);
                            // Classifica os movimentos para eficiência da poda Alpha-Beta dentro do minimax
                            moves.sort((a, b) => {
                                const targetPieceA = currentBoard[a[0]][a[1]]; // Peça no destino para o movimento A
                                const targetPieceB = currentBoard[b[0]][b[1]]; // Peça no destino para o movimento B
                                const valueA = targetPieceA ? Math.abs(PIECE_VALUES[targetPieceA]) : 0;
                                const valueB = targetPieceB ? Math.abs(PIECE_VALUES[targetPieceB]) : 0;
                                return valueB - valueA; // Prioriza capturas de peças de maior valor
                            });

                            for (const [toR, toC] of moves) {
                                // Simula o movimento
                                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                                const originalPiece = newBoard[r][c];
                                const capturedPiece = newBoard[toR][toC];

                                newBoard[toR][toC] = originalPiece;
                                newBoard[r][c] = '';

                                // Promoção de Peão no tabuleiro simulado
                                let simulatedMovedPiece = originalPiece;
                                if (originalPiece.toLowerCase() === 'p') {
                                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                                    }
                                }

                                // Simula a atualização das flags de roque para a chamada recursiva
                                const newCastlingFlags = { ...castlingFlags };
                                if (originalPiece === 'K') newCastlingFlags.whiteKingMoved = true;
                                if (originalPiece === 'k') newCastlingFlags.blackKingMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 0) newCastlingFlags.whiteRookLeftMoved = true;
                                if (originalPiece === 'R' && r === 7 && c === 7) newCastlingFlags.whiteRookRightMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 0) newCastlingFlags.blackRookLeftMoved = true;
                                if (originalPiece === 'r' && r === 0 && c === 7) newCastlingFlags.blackRookRightMoved = true;

                                // Lida com o movimento simulado da torre no roque
                                if (piece.toLowerCase() === 'k' && Math.abs(toC - c) === 2) {
                                    let rookOriginalCol;
                                    let rookFinalCol;
                                    if (toC > c) { // Roque do lado do rei
                                        rookOriginalCol = 7;
                                        rookFinalCol = c + 1;
                                    } else { // Roque do lado da rainha
                                        rookOriginalCol = 0;
                                        rookFinalCol = c - 1;
                                    }
                                    const rookPiece = newBoard[r][rookOriginalCol];
                                    newBoard[r][rookFinalCol] = rookPiece;
                                    newBoard[r][rookOriginalCol] = '';
                                }

                                const evaluation = minimax(newBoard, depth - 1, true, alpha, beta, newCastlingFlags);
                                minEval = Math.min(minEval, evaluation);
                                beta = Math.min(beta, minEval);

                                if (beta <= alpha) { // Poda Alpha-Beta
                                    break;
                                }
                            }
                        }
                    }
                }
                transpositionTable.set(boardHash, { evaluation: minEval, depth }); // Armazena a avaliação
                return minEval;
            }
        }

        /**
         * Faz um movimento para o computador (IA).
         */
        function makeComputerMove() {
            if (gameOver || currentPlayer !== 'black') {
                isThinking = false;
                updateHistoryButtons();
                updateStatus(); // Garante que o status seja atualizado se a IA não deveria se mover
                return;
            }

            let bestMove = null;
            let maxEval = -Infinity;
            const searchDepth = aiSearchDepth; // Usa a profundidade de busca da IA selecionada

            // Itera por todos os movimentos possíveis para a IA (peças pretas)
            const allPossibleMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && isBlackPiece(piece)) {
                        const moves = getLegalMoves(piece, r, c, board);
                        moves.forEach(([toR, toC]) => {
                            const pieceAtTargetForMove = board[toR][toC]; // Obtém a peça do tabuleiro real antes de simular
                            allPossibleMoves.push({
                                from: [r, c],
                                to: [toR, toC],
                                piece: piece,
                                capturedPiece: pieceAtTargetForMove, // Armazena o caractere da peça capturada real
                                capturedPieceValue: pieceAtTargetForMove ? Math.abs(PIECE_VALUES[pieceAtTargetForMove]) : 0
                            });
                        });
                    }
                }
            }

            // Classifica os movimentos para eficiência da poda Alpha-Beta
            allPossibleMoves.sort((a, b) => {
                // Prioriza capturas de peças de maior valor
                if (a.capturedPieceValue !== b.capturedPieceValue) {
                    return b.capturedPieceValue - a.capturedPieceValue; // Ordem decrescente para capturas
                }

                // Se o valor capturado for o mesmo, prioriza movimentos que dão xeque
                // Simula o tabuleiro para o movimento A
                const boardAfterA = JSON.parse(JSON.stringify(board));
                boardAfterA[a.to[0]][a.to[1]] = boardAfterA[a.from[0]][a.from[1]];
                boardAfterA[a.from[0]][a.from[1]] = '';
                // Simula o movimento da torre no roque para A, se aplicável
                if (a.piece.toLowerCase() === 'k' && Math.abs(a.to[1] - a.from[1]) === 2) {
                    let rookOriginalColA = (a.to[1] > a.from[1]) ? 7 : 0;
                    let rookFinalColA = (a.to[1] > a.from[1]) ? a.from[1] + 1 : a.from[1] - 1;
                    const rookPieceA = boardAfterA[a.from[0]][rookOriginalColA];
                    boardAfterA[a.from[0]][rookFinalColA] = rookPieceA;
                    boardAfterA[a.from[0]][rookOriginalColA] = '';
                }
                // Promoção de Peão no tabuleiro simulado para A (IA sempre promove para Rainha)
                if (a.piece.toLowerCase() === 'p') {
                    if ((isWhitePiece(a.piece) && a.to[0] === 0) || (isBlackPiece(a.piece) && a.to[0] === 7)) {
                        // Para classificação, assume temporariamente a promoção para rainha para uma verificação rápida
                        boardAfterA[a.to[0]][a.to[1]] = isWhitePiece(a.piece) ? 'Q' : 'q';
                    }
                }

                // Define temporariamente o jogador atual para preto para isKingInCheck
                const originalCurrentPlayer = currentPlayer;
                currentPlayer = 'black';
                const aGivesCheck = isKingInCheck('white', boardAfterA); // Verifica se o rei branco está em xeque
                currentPlayer = originalCurrentPlayer; // Reverte

                // Simula o tabuleiro para o movimento B
                const boardAfterB = JSON.parse(JSON.stringify(board));
                boardAfterB[b.to[0]][b.to[1]] = boardAfterB[b.from[0]][b.from[1]];
                boardAfterB[b.from[0]][b.from[1]] = '';
                // Simula o movimento da torre no roque para B, se aplicável
                if (b.piece.toLowerCase() === 'k' && Math.abs(b.to[1] - b.from[1]) === 2) {
                    let rookOriginalColB = (b.to[1] > b.from[1]) ? 7 : 0;
                    let rookFinalColB = (b.to[1] > b.from[1]) ? b.from[1] + 1 : b.from[1] - 1;
                    const rookPieceB = boardAfterB[b.from[0]][rookOriginalColB];
                    boardAfterB[b.from[0]][rookFinalColB] = rookPieceB;
                    boardAfterB[b.from[0]][rookOriginalColB] = '';
                }
                // Promoção de Peão no tabuleiro simulado para B (IA sempre promove para Rainha)
                if (b.piece.toLowerCase() === 'p') {
                    if ((isWhitePiece(b.piece) && b.to[0] === 0) || (isBlackPiece(b.piece) && b.to[0] === 7)) {
                        // Para classificação, assume temporariamente a promoção para rainha para uma verificação rápida
                        boardAfterB[b.to[0]][b.to[1]] = isWhitePiece(b.piece) ? 'Q' : 'q';
                    }
                }

                // Define temporariamente o jogador atual para preto para isKingInCheck
                currentPlayer = 'black';
                const bGivesCheck = isKingInCheck('white', boardAfterB); // Verifica se o rei branco está em xeque
                currentPlayer = originalCurrentPlayer; // Reverte

                if (aGivesCheck && !bGivesCheck) return -1; // A é melhor se der xeque e B não
                if (!aGivesCheck && bGivesCheck) return 1;  // B é melhor se der xeque e A não

                // Caso contrário, mantém a ordem original (aleatoriedade)
                return 0;
            });


            console.log("IA considerando movimentos:"); // Log de depuração
            for (const move of allPossibleMoves) {
                const { from: [fromR, fromC], to: [toR, toC], piece, capturedPiece, capturedPieceValue } = move;

                // Simula o movimento em um tabuleiro temporário
                const newBoard = JSON.parse(JSON.stringify(board));
                const originalPiece = newBoard[fromR][fromC];
                const simulatedCapturedPiece = newBoard[toR][toC]; // Peça que seria capturada na simulação

                newBoard[toR][toC] = originalPiece;
                newBoard[fromR][fromC] = '';

                // Promoção de Peão no tabuleiro simulado para a chamada minimax
                let simulatedMovedPiece = originalPiece;
                if (originalPiece.toLowerCase() === 'p') {
                    if ((isWhitePiece(originalPiece) && toR === 0) || (isBlackPiece(originalPiece) && toR === 7)) {
                        // Decide a melhor promoção para o jogador cujo peão está promovendo neste movimento simulado
                        simulatedMovedPiece = decidePromotionPieceForAI(newBoard, toR, toC, isWhitePiece(originalPiece));
                        newBoard[toR][toC] = simulatedMovedPiece; // Atualiza a peça no novo tabuleiro
                    }
                }


                // Simula a atualização das flags de roque para a chamada minimax
                const simulatedCastlingFlags = {
                    whiteKingMoved: whiteKingMoved,
                    blackKingMoved: blackKingMoved,
                    whiteRookLeftMoved: whiteRookLeftMoved,
                    whiteRookRightMoved: whiteRookRightMoved,
                    blackRookLeftMoved: blackRookLeftMoved,
                    blackRookRightMoved: blackRookRightMoved
                };
                if (originalPiece === 'K') simulatedCastlingFlags.whiteKingMoved = true;
                if (originalPiece === 'k') simulatedCastlingFlags.blackKingMoved = true;
                if (originalPiece === 'R' && fromR === 7 && fromC === 0) simulatedCastlingFlags.whiteRookLeftMoved = true;
                if (originalPiece === 'R' && fromR === 7 && fromC === 7) simulatedCastlingFlags.whiteRookRightMoved = true;
                if (originalPiece === 'r' && fromR === 0 && fromC === 0) simulatedCastlingFlags.blackRookLeftMoved = true;
                if (originalPiece === 'r' && fromR === 0 && fromC === 7) simulatedCastlingFlags.blackRookRightMoved = true;


                // Se for um movimento de roque, também move a torre no tabuleiro simulado
                if (piece.toLowerCase() === 'k' && Math.abs(toC - fromC) === 2) {
                    let rookOriginalCol;
                    if (toC > fromC) { // Roque do lado do rei
                        rookOriginalCol = 7;
                    } else { // Roque do lado da rainha
                        rookOriginalCol = 0;
                    }
                    const rookPiece = newBoard[fromR][rookOriginalCol];
                    let rookFinalCol;
                    if (toC > fromC) { // Roque do lado do rei
                        rookFinalCol = fromC + 1;
                    } else { // Roque do lado da rainha
                        rookFinalCol = fromC - 1;
                    }
                    newBoard[fromR][rookFinalCol] = rookPiece;
                    newBoard[fromR][rookOriginalCol] = '';
                }

                // Chama minimax com alpha e beta e flags de roque atuais
                const evaluation = minimax(newBoard, searchDepth - 1, false, -Infinity, Infinity, simulatedCastlingFlags);

                let moveDescription = `  Movimento: ${String.fromCharCode(97 + fromC)}${8 - fromR} -> ${String.fromCharCode(97 + toC)}${8 - toR} (Peça: ${piece})`;
                if (capturedPiece) {
                    moveDescription += `, CAPTURA: ${capturedPiece} (Valor: ${capturedPieceValue})`;
                } else {
                    moveDescription += `, Sem Captura`;
                }
                moveDescription += `, Avaliação: ${evaluation}`;
                console.log(moveDescription);

                if (evaluation > maxEval) {
                    maxEval = evaluation;
                    bestMove = move;
                } else if (evaluation === maxEval) {
                    // Se as avaliações forem iguais, prefere movimentos que capturam peças de maior valor
                    // Esta lógica agora é tratada pela classificação inicial.
                    // Mantém um desempate aleatório para movimentos verdadeiramente idênticos
                    if (Math.random() < 0.5) {
                        bestMove = move;
                    }
                }
            }

            if (bestMove) {
                // Executa o melhor movimento encontrado
                const { from: [fromR, fromC], to: [toR, toC], piece } = bestMove;
                console.log(`Melhor movimento escolhido: ${String.fromCharCode(97 + fromC)}${8 - fromR} -> ${String.fromCharCode(97 + toC)}${8 - toR}, Avaliação Máxima: ${maxEval}`); // Log de depuração

                // Determina a peça final para promoção se for uma promoção de peão
                let finalPromotedPiece = null;
                if (piece.toLowerCase() === 'p' && ((isWhitePiece(piece) && toR === 0) || (isBlackPiece(piece) && toR === 7))) {
                    finalPromotedPiece = decidePromotionPieceForAI(board, toR, toC, isWhitePiece(piece));
                }

                // Lida com o roque como um caso especial para a atualização do tabuleiro real
                if (piece.toLowerCase() === 'k' && Math.abs(toC - fromC) === 2) {
                    let rookOriginalCol;
                    if (toC > fromC) { // Roque do lado do rei
                        rookOriginalCol = 7;
                    } else { // Roque do lado da rainha
                        rookOriginalCol = 0;
                    }
                    makeCastlingMove(fromR, fromC, toR, rookOriginalCol);
                } else {
                    makeMove(fromR, fromC, toR, toC, finalPromotedPiece);
                }

                // deselectPiece(); // Desseleciona a peça após o movimento da IA (já está em makeMove/makeCastlingMove)
                // switchPlayer(); // Troca para o próximo jogador (humano) (já está em makeMove/makeCastlingMove)
                // saveCurrentState(); // Salva o movimento da IA no histórico (já está em makeMove/makeCastlingMove)
            } else {
                // Se nenhum melhor movimento for encontrado (ex: empate por afogamento ou xeque-mate detectado pela IA)
                console.warn("A IA não conseguiu encontrar um movimento. Isso pode indicar empate por afogamento ou xeque-mate.");
                // O estado do jogo já deve ser atualizado por switchPlayer se for xeque-mate/empate por afogamento
            }
            isThinking = false;
            updateHistoryButtons();
            updateStatus();
        }

        // Listener de evento para tentar bloquear o zoom com Ctrl + roda do mouse
        window.addEventListener('wheel', (e) => {
            if (e.ctrlKey) { // Verifica se a tecla Ctrl (ou Cmd no Mac) está pressionada
                e.preventDefault(); // Impede o comportamento padrão de zoom do navegador
            }
        }, { passive: false }); // Use { passive: false } para garantir que preventDefault() funcione

        // Listeners de eventos para os botões
        resetButton.addEventListener('click', () => initializeNewGame(gameMode)); // Reset irá reinicializar no modo atual
        undoButton.addEventListener('click', undoMove);
        redoButton.addEventListener('click', redoMove);
        backToMenuButton.addEventListener('click', showMainMenu); // Ainda apenas mostra o menu principal
        playVsComputerBtn.addEventListener('click', () => startGameMode('computer')); // Chama a nova função startGameMode
        playVsPlayerBtn.addEventListener('click', () => startGameMode('player')); // Chama a nova função startGameMode

        // Inicializa o jogo sempre mostrando o menu principal primeiro
        document.addEventListener('DOMContentLoaded', () => {
            initializeZobristTable(); // Inicializa a tabela Zobrist uma vez ao carregar
            // Oculta o menu principal e o contêiner do jogo até que a tela de carregamento desapareça
            mainMenuElement.classList.add('hidden'); // Garante que o menu principal esteja oculto
            mainMenuElement.style.display = 'none'; // Explicitamente define o display para none
            gameLayoutElement.classList.add('hidden'); // Garante que o layout do jogo esteja oculto
            gameLayoutElement.style.display = 'none'; // Explicitamente define o display para none
            loadingScreenElement.classList.remove('hidden'); // Garante que a tela de carregamento esteja visível

            // Precarrega a imagem de fundo e só então esconde a tela de carregamento
            const backgroundImage = new Image();
            backgroundImage.src = BACKGROUND_IMAGE_URL;
            backgroundImage.onload = () => {
                loadingScreenElement.classList.add('hidden'); // Oculta a tela de carregamento
                showMainMenu(); // Mostra o menu principal
            };
            backgroundImage.onerror = () => {
                console.error("Erro ao carregar a imagem de fundo. Prosseguindo sem ela.");
                loadingScreenElement.classList.add('hidden'); // Oculta a tela de carregamento mesmo com erro
                showMainMenu(); // Mostra o menu principal
            };
        });
    </script>
</body>
</html>
